import{M as h,b3 as C,I as j,T as Y}from"./three.module-DBfedTbk.js";function y(...v){return v.join("_")}class b{constructor(){this.cache={},this.count=0,this.cachedBytes=0,this.active=0}fetchItem(){}disposeItem(){}getMemoryUsage(t){return 0}setData(...t){const{cache:i}=this,e=t.pop(),n=y(...t);if(n in i)throw new Error(`DataCache: "${n}" is already present.`);return this.cache[n]={abortController:new AbortController,result:e,count:1,bytes:this.getMemoryUsage(e)},this.count++,this.cachedBytes+=this.cache[n].bytes,e}lock(...t){const{cache:i}=this,e=y(...t);if(e in i)i[e].count++;else{const n=new AbortController,o={abortController:n,result:null,count:1,bytes:0};this.active++,o.result=this.fetchItem(t,n.signal),o.result instanceof Promise?o.result.then(s=>(o.result=s,o.bytes=this.getMemoryUsage(s),this.cachedBytes+=o.bytes,s)).finally(()=>{this.active--}).catch(s=>{}):(this.active--,o.bytes=this.getMemoryUsage(o.result),this.cachedBytes+=o.bytes),this.cache[e]=o,this.count++}return i[e].result}release(...t){const i=y(...t);this.releaseViaFullKey(i)}get(...t){const{cache:i}=this,e=y(...t);return e in i&&i[e].count>0?i[e].result:null}has(...t){const{cache:i}=this;return y(...t)in i}dispose(){const{cache:t}=this;for(const i in t){const{abortController:e}=t[i];e.abort(),this.releaseViaFullKey(i,!0)}this.cache={}}releaseViaFullKey(t,i=!1){const{cache:e}=this;if(t in e&&e[t].count>0){const n=e[t];if(n.count--,n.count===0||i){const o=()=>{if(e[t]!==n)return;const{result:s,abortController:c}=n;c.abort(),s instanceof Promise?s.then(r=>{this.disposeItem(r),this.count--,this.cachedBytes-=n.bytes}).catch(()=>{}):(this.disposeItem(s),this.count--,this.cachedBytes-=n.bytes),delete e[t]};i?o():queueMicrotask(()=>{n.count===0&&o()})}return!0}throw new Error("DataCache: Attempting to release key that does not exist")}}function P(v,t){const[i,e,n,o]=v,[s,c,r,l]=t;return!(i>=r||n<=s||e>=l||o<=c)}class X{get levelCount(){return this._levels.length}get maxLevel(){return this.levelCount-1}get minLevel(){const t=this._levels;for(let i=0;i<t.length;i++)if(t[i]!==null)return i;return-1}get contentBounds(){var t;return this._contentBounds??((t=this.projection)==null?void 0:t.getBounds())??[0,0,1,1]}get aspectRatio(){const{pixelWidth:t,pixelHeight:i}=this.getLevel(this.maxLevel);return t/i}constructor(){this.flipY=!1,this.pixelOverlap=0,this._contentBounds=null,this.projection=null,this._levels=[]}setLevel(t,i={}){const e=this._levels;for(;e.length<t;)e.push(null);const{tilePixelWidth:n=256,tilePixelHeight:o=256,tileCountX:s=2**t,tileCountY:c=2**t,tileBounds:r=null}=i,{pixelWidth:l=n*s,pixelHeight:m=o*c}=i;e[t]={tilePixelWidth:n,tilePixelHeight:o,pixelWidth:l,pixelHeight:m,tileCountX:s,tileCountY:c,tileBounds:r}}generateLevels(t,i,e,n={}){const{minLevel:o=0,tilePixelWidth:s=256,tilePixelHeight:c=256}=n,r=t-1,{pixelWidth:l=s*i*2**r,pixelHeight:m=c*e*2**r}=n;for(let u=o;u<t;u++){const g=t-u-1,x=Math.ceil(l*2**-g),f=Math.ceil(m*2**-g),p=Math.ceil(x/s),T=Math.ceil(f/c);this.setLevel(u,{tilePixelWidth:s,tilePixelHeight:c,pixelWidth:x,pixelHeight:f,tileCountX:p,tileCountY:T})}}getLevel(t){return this._levels[t]}setContentBounds(t,i,e,n){this._contentBounds=[t,i,e,n]}setProjection(t){this.projection=t}getTileAtPoint(t,i,e,n=!1){const{flipY:o}=this,{tileCountX:s,tileCountY:c,tileBounds:r}=this.getLevel(e),l=1/s,m=1/c;if(n||([t,i]=this.toNormalizedPoint(t,i)),r){const x=this.toNormalizedRange(r);t=h.mapLinear(t,x[0],x[2],0,1),i=h.mapLinear(i,x[1],x[3],0,1)}const u=Math.floor(t/l);let g=Math.floor(i/m);return o&&(g=c-1-g),[u,g]}getTilesInRange(t,i,e,n,o,s=!1){const c=[t,i,e,n],r=this.getContentBounds(s);let l=this.getLevel(o).tileBounds;if(!P(c,r))return[0,0,-1,-1];if(l&&(s&&(l=this.toNormalizedRange(l)),!P(c,r)))return[0,0,-1,-1];const[m,u,g,x]=this.clampToContentBounds(c,s),f=this.getTileAtPoint(m,u,o,s),p=this.getTileAtPoint(g,x,o,s);this.flipY&&([f[1],p[1]]=[p[1],f[1]]);const{tileCountX:T,tileCountY:B}=this.getLevel(o),[a,d]=f,[M,L]=p;return M<0||L<0||a>=T||d>=B?[0,0,-1,-1]:[h.clamp(a,0,T-1),h.clamp(d,0,B-1),h.clamp(M,0,T-1),h.clamp(L,0,B-1)]}getTileExists(t,i,e){const[n,o,s,c]=this.contentBounds,[r,l,m,u]=this.getTileBounds(t,i,e);return!(r>=m||l>=u)&&r<=s&&l<=c&&m>=n&&u>=o}getContentBounds(t=!1){const{projection:i}=this,e=[...this.contentBounds];return i&&t&&(e[0]=i.convertLongitudeToProjection(e[0]),e[1]=i.convertLatitudeToProjection(e[1]),e[2]=i.convertLongitudeToProjection(e[2]),e[3]=i.convertLatitudeToProjection(e[3])),e}getTileContentUVBounds(t,i,e){const[n,o,s,c]=this.getTileBounds(t,i,e,!0,!0),[r,l,m,u]=this.getTileBounds(t,i,e,!0,!1);return[h.mapLinear(n,r,m,0,1),h.mapLinear(o,l,u,0,1),h.mapLinear(s,r,m,0,1),h.mapLinear(c,l,u,0,1)]}getTileBounds(t,i,e,n=!1,o=!0){const{flipY:s,pixelOverlap:c,projection:r}=this,{tilePixelWidth:l,tilePixelHeight:m,pixelWidth:u,pixelHeight:g,tileBounds:x}=this.getLevel(e);let f=l*t-c,p=m*i-c,T=f+l+c*2,B=p+m+c*2;if(f=Math.max(f,0),p=Math.max(p,0),T=Math.min(T,u),B=Math.min(B,g),f=f/u,T=T/u,p=p/g,B=B/g,s){const d=(B-p)/2,L=1-(p+B)/2;p=L-d,B=L+d}let a=[f,p,T,B];if(x){const d=this.toNormalizedRange(x);a[0]=h.mapLinear(a[0],0,1,d[0],d[2]),a[2]=h.mapLinear(a[2],0,1,d[0],d[2]),a[1]=h.mapLinear(a[1],0,1,d[1],d[3]),a[3]=h.mapLinear(a[3],0,1,d[1],d[3])}return o&&(a=this.clampToProjectionBounds(a,!0)),r&&!n&&(a[0]=r.convertProjectionToLongitude(a[0]),a[1]=r.convertProjectionToLatitude(a[1]),a[2]=r.convertProjectionToLongitude(a[2]),a[3]=r.convertProjectionToLatitude(a[3])),a}toNormalizedPoint(t,i){const{projection:e}=this,n=[t,i];return this.projection&&(n[0]=e.convertLongitudeToProjection(n[0]),n[1]=e.convertLatitudeToProjection(n[1])),n}toNormalizedRange(t){return[...this.toNormalizedPoint(t[0],t[1]),...this.toNormalizedPoint(t[2],t[3])]}toCartographicPoint(t,i){const{projection:e}=this,n=[t,i];if(this.projection)n[0]=e.convertProjectionToLongitude(n[0]),n[1]=e.convertProjectionToLatitude(n[1]);else throw new Error("TilingScheme: Projection not available.");return n}toCartographicRange(t){return[...this.toCartographicPoint(t[0],t[1]),...this.toCartographicPoint(t[2],t[3])]}clampToContentBounds(t,i=!1){const e=[...t],[n,o,s,c]=this.getContentBounds(i);return e[0]=h.clamp(e[0],n,s),e[1]=h.clamp(e[1],o,c),e[2]=h.clamp(e[2],n,s),e[3]=h.clamp(e[3],o,c),e}clampToProjectionBounds(t,i=!1){const e=[...t],{projection:n}=this;let o;i||!n?o=[0,0,1,1]:o=n.getBounds();const[s,c,r,l]=o;return e[0]=h.clamp(e[0],s,r),e[1]=h.clamp(e[1],c,l),e[2]=h.clamp(e[2],s,r),e[3]=h.clamp(e[3],c,l),e}}class w extends b{constructor(t={}){super();const{fetchOptions:i={}}=t;this.tiling=new X,this.fetchOptions=i,this.fetchData=(...e)=>fetch(...e)}init(){}async processBufferToTexture(t){const i=new Blob([t]),e=await createImageBitmap(i,{premultiplyAlpha:"none",colorSpaceConversion:"none",imageOrientation:"flipY"}),n=new C(e);return n.generateMipmaps=!1,n.colorSpace=j,n.needsUpdate=!0,n}getMemoryUsage(t){const{format:i,type:e,image:n,generateMipmaps:o}=t,{width:s,height:c}=n,r=Y.getByteLength(s,c,i,e);return o?r*4/3:r}fetchItem(t,i){const e={...this.fetchOptions,signal:i},n=this.getUrl(...t);return this.fetchData(n,e).then(o=>o.arrayBuffer()).then(o=>this.processBufferToTexture(o))}disposeItem(t){t.dispose(),t.image instanceof ImageBitmap&&t.image.close()}getUrl(...t){}}export{w as T,X as a};
//# sourceMappingURL=TiledImageSource-smoHuTDQ.js.map
