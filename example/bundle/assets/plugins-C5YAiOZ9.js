import{C as kt,G as Pt,h as It}from"./GeometryClipper-OrdjW0tI.js";import{a as St}from"./TilesRenderer-urYYbZ2A.js";import{T as Ut}from"./EPSGTilesPlugin-at5sGeAp.js";import{aY as Ct,ak as Et,f as Mt,i as Nt,m as Q,al as ot,e as Vt,Z as Ot,$ as zt,aZ as Gt,z as Ht,M as nt,ao as Bt,V as pt}from"./three.module-DBfedTbk.js";import{L as Dt}from"./BatchTable-CRr3zuRk.js";import{E as wt}from"./Ellipsoid-CLPX16sm.js";import{a as Ft}from"./TiledImageSource-smoHuTDQ.js";import{P as jt}from"./TMSImageSource-D41Rs33p.js";class $t{constructor(){this.creditsCount={}}_adjustAttributions(t,e){const s=this.creditsCount,n=t.split(/;/g);for(let i=0,c=n.length;i<c;i++){const b=n[i];b in s||(s[b]=0),s[b]+=e?1:-1,s[b]<=0&&delete s[b]}}addAttributions(t){this._adjustAttributions(t,!0)}removeAttributions(t){this._adjustAttributions(t,!1)}toString(){return Object.entries(this.creditsCount).sort((e,s)=>{const n=e[1];return s[1]-n}).map(e=>e[0]).join("; ")}}const qt="https://tile.googleapis.com/v1/3dtiles/root.json";class Qt{constructor({apiToken:t,sessionOptions:e=null,autoRefreshToken:s=!1,logoUrl:n=null,useRecommendedSettings:i=!0}){this.name="GOOGLE_CLOUD_AUTH_PLUGIN",this.apiToken=t,this.useRecommendedSettings=i,this.logoUrl=n,this.auth=new Xt({apiToken:t,autoRefreshToken:s,sessionOptions:e}),this.tiles=null,this._visibilityChangeCallback=null,this._attributionsManager=new $t,this._logoAttribution={value:"",type:"image",collapsible:!1},this._attribution={value:"",type:"string",collapsible:!0}}init(t){const{useRecommendedSettings:e,auth:s}=this;t.resetFailedTiles(),t.rootURL==null&&(t.rootURL=qt),s.sessionOptions||(s.authURL=t.rootURL),e&&!s.isMapTilesSession&&(t.errorTarget=20),this.tiles=t,this._visibilityChangeCallback=({tile:n,visible:i})=>{var b,l;const c=((l=(b=n.cached.metadata)==null?void 0:b.asset)==null?void 0:l.copyright)||"";i?this._attributionsManager.addAttributions(c):this._attributionsManager.removeAttributions(c)},t.addEventListener("tile-visibility-change",this._visibilityChangeCallback)}getAttributions(t){this.tiles.visibleTiles.size>0&&(this.logoUrl&&(this._logoAttribution.value=this.logoUrl,t.push(this._logoAttribution)),this._attribution.value=this._attributionsManager.toString(),t.push(this._attribution))}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._visibilityChangeCallback)}async fetchData(t,e){return this.auth.fetch(t,e)}}let Yt=class{get apiToken(){return this.auth.apiToken}set apiToken(t){this.auth.apiToken=t}get autoRefreshToken(){return this.auth.autoRefreshToken}set autoRefreshToken(t){this.auth.autoRefreshToken=t}constructor(t={}){const{apiToken:e,assetId:s=null,autoRefreshToken:n=!1,useRecommendedSettings:i=!0,assetTypeHandler:c=(b,l,p)=>{console.warn(`CesiumIonAuthPlugin: Cesium Ion asset type "${b}" unhandled.`)}}=t;this.name="CESIUM_ION_AUTH_PLUGIN",this.auth=new kt({apiToken:e,autoRefreshToken:n}),this.assetId=s,this.autoRefreshToken=n,this.useRecommendedSettings=i,this.assetTypeHandler=c,this.tiles=null,this._tileSetVersion=-1,this._attributions=[]}init(t){this.assetId!==null&&(t.rootURL=`https://api.cesium.com/v1/assets/${this.assetId}/endpoint`),this.tiles=t,this.auth.authURL=t.rootURL,t.resetFailedTiles()}loadRootTileset(){return this.auth.refreshToken().then(t=>(this._initializeFromAsset(t),this.tiles.invokeOnePlugin(e=>e!==this&&e.loadRootTileset&&e.loadRootTileset()))).catch(t=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:t,url:this.auth.authURL})})}preprocessURL(t){return t=new URL(t),/^http/.test(t.protocol)&&this._tileSetVersion!=-1&&t.searchParams.set("v",this._tileSetVersion),t.toString()}fetchData(t,e){return this.tiles.getPluginByName("GOOGLE_CLOUD_AUTH_PLUGIN")!==null?null:this.auth.fetch(t,e)}getAttributions(t){this.tiles.visibleTiles.size>0&&t.push(...this._attributions)}_initializeFromAsset(t){const e=this.tiles;if("externalType"in t){const s=new URL(t.options.url);e.rootURL=t.options.url,e.registerPlugin(new Qt({apiToken:s.searchParams.get("key"),autoRefreshToken:this.autoRefreshToken,useRecommendedSettings:this.useRecommendedSettings}))}else{t.type!=="3DTILES"&&this.assetTypeHandler(t.type,e,t),e.rootURL=t.url;const s=new URL(t.url);s.searchParams.has("v")&&this._tileSetVersion===-1&&(this._tileSetVersion=s.searchParams.get("v")),t.attributions&&(this._attributions=t.attributions.map(n=>({value:n.html,type:"html",collapsible:n.collapsible})))}}};const gt="https://tile.googleapis.com/v1/createSession";class Xt{get isMapTilesSession(){return this.authURL===gt}constructor(t={}){const{apiToken:e,sessionOptions:s=null,autoRefreshToken:n=!1}=t;this.apiToken=e,this.autoRefreshToken=n,this.authURL=gt,this.sessionToken=null,this.sessionOptions=s,this._tokenRefreshPromise=null}async fetch(t,e){this.sessionToken===null&&this.isMapTilesSession&&this.refreshToken(e),await this._tokenRefreshPromise;const s=new URL(t);s.searchParams.set("key",this.apiToken),this.sessionToken&&s.searchParams.set("session",this.sessionToken);let n=await fetch(s,e);return n.status>=400&&n.status<=499&&this.autoRefreshToken&&(await this.refreshToken(e),this.sessionToken&&s.searchParams.set("session",this.sessionToken),n=await fetch(s,e)),this.sessionToken===null&&!this.isMapTilesSession?n.json().then(i=>(this.sessionToken=ft(i),i)):n}refreshToken(t){if(this._tokenRefreshPromise===null){const e=new URL(this.authURL);e.searchParams.set("key",this.apiToken);const s={...t};this.isMapTilesSession&&(s.method="POST",s.body=JSON.stringify(this.sessionOptions),s.headers=s.headers||{},s.headers={...s.headers,"Content-Type":"application/json"}),this._tokenRefreshPromise=fetch(e,s).then(n=>{if(!n.ok)throw new Error(`GoogleCloudAuth: Failed to load data with error code ${n.status}`);return n.json()}).then(n=>(this.sessionToken=ft(n),this._tokenRefreshPromise=null,n))}return this._tokenRefreshPromise}}function ft(f){if("session"in f)return f.session;{let t=null;const e=f.root;return St(e,s=>{if(s.content&&s.content.uri){const[,n]=s.content.uri.split("?");return t=new URLSearchParams(n).get("session"),!0}return!1}),t}}function ht(f){return f>>1^-(f&1)}class Zt extends Dt{constructor(...t){super(...t),this.fetchOptions.header={Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9"}}loadAsync(...t){const{fetchOptions:e}=this;return e.header=e.header||{},e.header.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",e.header.Accept+=";extensions=octvertexnormals-watermask-metadata",super.loadAsync(...t)}parse(t){let e=0;const s=new DataView(t),n=()=>{const a=s.getFloat64(e,!0);return e+=8,a},i=()=>{const a=s.getFloat32(e,!0);return e+=4,a},c=()=>{const a=s.getUint32(e,!0);return e+=4,a},b=()=>{const a=s.getUint8(e);return e+=1,a},l=(a,O)=>{const D=new O(t,e,a);return e+=a*O.BYTES_PER_ELEMENT,D},p={center:[n(),n(),n()],minHeight:i(),maxHeight:i(),sphereCenter:[n(),n(),n()],sphereRadius:n(),horizonOcclusionPoint:[n(),n(),n()]},d=c(),m=l(d,Uint16Array),E=l(d,Uint16Array),T=l(d,Uint16Array),h=new Float32Array(d),L=new Float32Array(d),v=new Float32Array(d);let y=0,R=0,G=0;const o=32767;for(let a=0;a<d;++a)y+=ht(m[a]),R+=ht(E[a]),G+=ht(T[a]),h[a]=y/o,L[a]=R/o,v[a]=G/o;const g=d>65536,k=g?Uint32Array:Uint16Array;g?e=Math.ceil(e/4)*4:e=Math.ceil(e/2)*2;const _=c(),V=l(_*3,k);let $=0;for(var Y=0;Y<V.length;++Y){const a=V[Y];V[Y]=$-a,a===0&&++$}const J=(a,O)=>L[O]-L[a],F=(a,O)=>-J(a,O),j=(a,O)=>h[a]-h[O],r=(a,O)=>-j(a,O),u=c(),w=l(u,k);w.sort(J);const U=c(),A=l(U,k);A.sort(j);const M=c(),C=l(M,k);C.sort(F);const P=c(),I=l(P,k);I.sort(r);const x={westIndices:w,southIndices:A,eastIndices:C,northIndices:I},N={};for(;e<s.byteLength;){const a=b(),O=c();if(a===1){const D=l(d*2,Uint8Array),H=new Float32Array(d*3);for(let q=0;q<d;q++){let Z=D[2*q+0]/255*2-1,X=D[2*q+1]/255*2-1;const it=1-(Math.abs(Z)+Math.abs(X));if(it<0){const mt=Z;Z=(1-Math.abs(X))*yt(mt),X=(1-Math.abs(mt))*yt(X)}const lt=Math.sqrt(Z*Z+X*X+it*it);H[3*q+0]=Z/lt,H[3*q+1]=X/lt,H[3*q+2]=it/lt}N.octvertexnormals={extensionId:a,normals:H}}else if(a===2){const D=O===1?1:256,H=l(D*D,Uint8Array);N.watermask={extensionId:a,mask:H,size:D}}else if(a===4){const D=c(),H=l(D,Uint8Array),q=new TextDecoder().decode(H);N.metadata={extensionId:a,json:JSON.parse(q)}}}return{header:p,indices:V,vertexData:{u:h,v:L,height:v},edgeIndices:x,extensions:N}}}function yt(f){return f<0?-1:1}const bt=new Q,rt=new Bt,S=new Q,K=new Q;class Jt extends Zt{constructor(t=Ct){super(),this.manager=t,this.ellipsoid=new wt,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI}parse(t){const{ellipsoid:e,solid:s,skirtLength:n,smoothSkirtNormals:i,minLat:c,maxLat:b,minLon:l,maxLon:p}=this,{header:d,indices:m,vertexData:E,edgeIndices:T,extensions:h}=super.parse(t),L=new Et,v=new Mt,y=new Nt(L,v);y.position.set(...d.center);const R="octvertexnormals"in h,G=E.u.length,o=[],g=[],k=[],_=[];let V=0,$=0;for(let r=0;r<G;r++)J(r,S),F(S.x,S.y,S.z,K),g.push(S.x,S.y),o.push(...K);for(let r=0,u=m.length;r<u;r++)k.push(m[r]);if(R){const r=h.octvertexnormals.normals;for(let u=0,w=r.length;u<w;u++)_.push(r[u])}if(L.addGroup(V,m.length,$),V+=m.length,$++,s){const r=o.length/3;for(let u=0;u<G;u++)J(u,S),F(S.x,S.y,S.z,K,-n),g.push(S.x,S.y),o.push(...K);for(let u=m.length-1;u>=0;u--)k.push(m[u]+r);if(R){const u=h.octvertexnormals.normals;for(let w=0,U=u.length;w<U;w++)_.push(-u[w])}L.addGroup(V,m.length,$),V+=m.length,$++}if(n>0){const{westIndices:r,eastIndices:u,southIndices:w,northIndices:U}=T;let A;const M=j(r);A=o.length/3,g.push(...M.uv),o.push(...M.positions);for(let x=0,N=M.indices.length;x<N;x++)k.push(M.indices[x]+A);const C=j(u);A=o.length/3,g.push(...C.uv),o.push(...C.positions);for(let x=0,N=C.indices.length;x<N;x++)k.push(C.indices[x]+A);const P=j(w);A=o.length/3,g.push(...P.uv),o.push(...P.positions);for(let x=0,N=P.indices.length;x<N;x++)k.push(P.indices[x]+A);const I=j(U);A=o.length/3,g.push(...I.uv),o.push(...I.positions);for(let x=0,N=I.indices.length;x<N;x++)k.push(I.indices[x]+A);R&&(_.push(...M.normals),_.push(...C.normals),_.push(...P.normals),_.push(...I.normals)),L.addGroup(V,m.length,$),V+=m.length,$++}for(let r=0,u=o.length;r<u;r+=3)o[r+0]-=d.center[0],o[r+1]-=d.center[1],o[r+2]-=d.center[2];const Y=o.length/3>65535?new Uint32Array(k):new Uint16Array(k);if(L.setIndex(new ot(Y,1,!1)),L.setAttribute("position",new ot(new Float32Array(o),3,!1)),L.setAttribute("uv",new ot(new Float32Array(g),2,!1)),R&&L.setAttribute("normal",new ot(new Float32Array(_),3,!1)),"watermask"in h){const{mask:r,size:u}=h.watermask,w=new Uint8Array(2*u*u);for(let A=0,M=r.length;A<M;A++){const C=r[A]===255?0:255;w[2*A+0]=C,w[2*A+1]=C}const U=new Vt(w,u,u,Ot,zt);U.flipY=!0,U.minFilter=Gt,U.magFilter=Ht,U.needsUpdate=!0,v.roughnessMap=U}return y.userData.minHeight=d.minHeight,y.userData.maxHeight=d.maxHeight,"metadata"in h&&(y.userData.metadata=h.metadata.json),y;function J(r,u){return u.x=E.u[r],u.y=E.v[r],u.z=E.height[r],u}function F(r,u,w,U,A=0){const M=nt.lerp(d.minHeight,d.maxHeight,w),C=nt.lerp(l,p,r),P=nt.lerp(c,b,u);return e.getCartographicToPosition(P,C,M+A,U),U}function j(r){const u=[],w=[],U=[],A=[],M=[];for(let I=0,x=r.length;I<x;I++)J(r[I],S),u.push(S.x,S.y),U.push(S.x,S.y),F(S.x,S.y,S.z,K),w.push(...K),F(S.x,S.y,S.z,K,-n),A.push(...K);const C=r.length-1;for(let I=0;I<C;I++){const x=I,N=I+1,a=I+r.length,O=I+r.length+1;M.push(x,a,N),M.push(N,a,O)}let P=null;if(R){const I=(w.length+A.length)/3;if(i){P=new Array(I*3);const x=h.octvertexnormals.normals,N=P.length/2;for(let a=0,O=I/2;a<O;a++){const D=r[a],H=3*a,q=x[3*D+0],Z=x[3*D+1],X=x[3*D+2];P[H+0]=q,P[H+1]=Z,P[H+2]=X,P[N+H+0]=q,P[N+H+1]=Z,P[N+H+2]=X}}else{P=[],rt.a.fromArray(w,0),rt.b.fromArray(A,0),rt.c.fromArray(w,3),rt.getNormal(bt);for(let x=0;x<I;x++)P.push(...bt)}}return{uv:[...u,...U],positions:[...w,...A],indices:M,normals:P}}}}const Lt={},Kt=new Q,ut=new Q,ct=new Q,Wt=new Q,te=new Q,B=new Q,et=new Q,z=new pt,W=new pt,At=new pt;class ee extends Pt{constructor(){super(),this.ellipsoid=new wt,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI,this.attributeList=["position","normal","uv"]}clipToQuadrant(t,e,s){const{solid:n,skirtLength:i,ellipsoid:c,smoothSkirtNormals:b}=this;this.clearSplitOperations(),this.addSplitOperation(xt("x"),!e),this.addSplitOperation(xt("y"),!s);let l,p;const d=t.geometry.groups[0],m=this.getClippedData(t,d);if(this.adjustVertices(m,t.position,0),n){l={index:m.index.slice().reverse(),attributes:{}};for(const g in m.attributes)l.attributes[g]=m.attributes[g].slice();const o=l.attributes.normal;if(o)for(let g=0;g<o.length;g+=3)o[g+0]*=-1,o[g+1]*=-1,o[g+2]*=-1;this.adjustVertices(l,t.position,-i)}if(i>0){p={index:[],attributes:{position:[],normal:[],uv:[]}};let o=0;const g={},k=(F,j,r)=>{const u=It(...F,...r,...j);u in g||(g[u]=o,o++,p.attributes.position.push(...F),p.attributes.normal.push(...r),p.attributes.uv.push(...j)),p.index.push(g[u])},_=m.index,V=m.attributes.uv,$=m.attributes.position,Y=m.attributes.normal,J=m.index.length/3;for(let F=0;F<J;F++){const j=3*F;for(let r=0;r<3;r++){const u=(r+1)%3,w=_[j+r],U=_[j+u];if(z.fromArray(V,w*2),W.fromArray(V,U*2),z.x===W.x&&(z.x===0||z.x===.5||z.x===1)||z.y===W.y&&(z.y===0||z.y===.5||z.y===1)){ut.fromArray($,w*3),ct.fromArray($,U*3);const A=ut,M=ct,C=Wt.copy(ut),P=te.copy(ct);B.copy(C).add(t.position),c.getPositionToNormal(B,B),C.addScaledVector(B,-i),B.copy(P).add(t.position),c.getPositionToNormal(B,B),P.addScaledVector(B,-i),b&&Y?(B.fromArray(Y,w*3),et.fromArray(Y,U*3)):(B.subVectors(A,M),et.subVectors(A,C).cross(B).normalize(),B.copy(et)),k(M,W,et),k(A,z,B),k(C,z,B),k(M,W,et),k(C,z,B),k(P,W,et)}}}}const E=m.index.length,T=m;if(l){const{index:o,attributes:g}=l,k=T.attributes.position.length/3;for(let _=0,V=o.length;_<V;_++)T.index.push(o[_]+k);for(const _ in m.attributes)T.attributes[_].push(...g[_])}if(p){const{index:o,attributes:g}=p,k=T.attributes.position.length/3;for(let _=0,V=o.length;_<V;_++)T.index.push(o[_]+k);for(const _ in m.attributes)T.attributes[_].push(...g[_])}const h=e?0:-.5,L=s?0:-.5,v=T.attributes.uv;for(let o=0,g=v.length;o<g;o+=2)v[o]=(v[o]+h)*2,v[o+1]=(v[o+1]+L)*2;const y=this.constructMesh(T.attributes,T.index,t);y.userData.minHeight=t.userData.minHeight,y.userData.maxHeight=t.userData.maxHeight;let R=0,G=0;return y.geometry.addGroup(G,E,R),G+=E,R++,l&&(y.geometry.addGroup(G,l.index.length,R),G+=l.index.length,R++),p&&(y.geometry.addGroup(G,p.index.length,R),G+=p.index.length,R++),y}adjustVertices(t,e,s){const{ellipsoid:n,minLat:i,maxLat:c,minLon:b,maxLon:l}=this,{attributes:p,vertexIsClipped:d}=t,m=p.position,E=p.uv,T=m.length/3;for(let h=0;h<T;h++){const L=z.fromArray(E,h*2);d&&d[h]&&(Math.abs(L.x-.5)<1e-10&&(L.x=.5),Math.abs(L.y-.5)<1e-10&&(L.y=.5),z.toArray(E,h*2));const v=nt.lerp(i,c,L.y),y=nt.lerp(b,l,L.x),R=Kt.fromArray(m,h*3).add(e);n.getPositionToCartographic(R,Lt),n.getCartographicToPosition(v,y,Lt.height+s,R),R.sub(e),R.toArray(m,h*3)}}}function xt(f){return(t,e,s,n,i)=>{const c=t.attributes.uv;return z.fromBufferAttribute(c,e),W.fromBufferAttribute(c,s),At.fromBufferAttribute(c,n),z[f]*i.x+W[f]*i.y+At[f]*i.z-.5}}const Tt=Symbol("TILE_X"),vt=Symbol("TILE_Y"),st=Symbol("TILE_LEVEL"),tt=Symbol("TILE_AVAILABLE"),at=1e4,_t=new Q;function se(f,t,e,s){if(f&&t<f.length){const n=f[t];for(let i=0,c=n.length;i<c;i++){const{startX:b,startY:l,endX:p,endY:d}=n[i];if(e>=b&&e<=p&&s>=l&&s<=d)return!0}}return!1}function Rt(f){const{available:t=null,maxzoom:e=null}=f;return e===null?t.length-1:e}function ne(f){const{metadataAvailability:t=-1}=f;return t}function dt(f,t){const e=f[st],s=ne(t),n=Rt(t);return e<n&&s!==-1&&e%s===0}function ie(f,t,e,s,n){return n.tiles[0].replace(/{\s*z\s*}/g,e).replace(/{\s*x\s*}/g,f).replace(/{\s*y\s*}/g,t).replace(/{\s*version\s*}/g,s)}class oe{constructor(t={}){const{useRecommendedSettings:e=!0,skirtLength:s=null,smoothSkirtNormals:n=!0,solid:i=!1}=t;this.name="QUANTIZED_MESH_PLUGIN",this.priority=-1e3,this.tiles=null,this.layer=null,this.useRecommendedSettings=e,this.skirtLength=s,this.smoothSkirtNormals=n,this.solid=i,this.attribution=null,this.tiling=new Ft,this.projection=new jt}init(t){t.fetchOptions.headers=t.fetchOptions.headers||{},t.fetchOptions.headers.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",this.useRecommendedSettings&&(t.errorTarget=2),this.tiles=t}loadRootTileset(){const{tiles:t}=this;let e=new URL("layer.json",new URL(t.rootURL,location.href));return t.invokeAllPlugins(s=>e=s.preprocessURL?s.preprocessURL(e,null):e),t.invokeOnePlugin(s=>s.fetchData&&s.fetchData(e,this.tiles.fetchOptions)).then(s=>s.json()).then(s=>{this.layer=s;const{projection:n="EPSG:4326",extensions:i=[],attribution:c="",available:b=null}=s,{tiling:l,tiles:p,projection:d}=this;c&&(this.attribution={value:c,type:"string",collapsible:!0}),i.length>0&&(p.fetchOptions.headers.Accept+=`;extensions=${i.join("-")}`),d.setScheme(n);const{tileCountX:m,tileCountY:E}=d;l.setProjection(d),l.generateLevels(Rt(s)+1,m,E);const T=[];for(let v=0;v<m;v++){const y=this.createChild(0,v,0,b);y&&T.push(y)}const h={asset:{version:"1.1"},geometricError:1/0,root:{refine:"REPLACE",geometricError:1/0,boundingVolume:{region:[...this.tiling.getContentBounds(),-at,at]},children:T,[tt]:b,[st]:-1}};let L=p.rootURL;return p.invokeAllPlugins(v=>L=v.preprocessURL?v.preprocessURL(L,null):L),p.preprocessTileset(h,L),h})}parseToMesh(t,e,s,n){const{skirtLength:i,solid:c,smoothSkirtNormals:b,tiles:l}=this,p=l.ellipsoid;let d;if(s==="quantized_tile_split"){const h=new URL(n).searchParams,L=h.get("left")==="true",v=h.get("bottom")==="true",y=new ee;y.ellipsoid.copy(p),y.solid=c,y.smoothSkirtNormals=b,y.skirtLength=i===null?e.geometricError:i;const[R,G,o,g]=e.parent.boundingVolume.region;y.minLat=G,y.maxLat=g,y.minLon=R,y.maxLon=o,d=y.clipToQuadrant(e.parent.cached.scene,L,v)}else if(s==="terrain"){const h=new Jt(l.manager);h.ellipsoid.copy(p),h.solid=c,h.smoothSkirtNormals=b,h.skirtLength=i===null?e.geometricError:i;const[L,v,y,R]=e.boundingVolume.region;h.minLat=v,h.maxLat=R,h.minLon=L,h.maxLon=y,d=h.parse(t)}else return;const{minHeight:m,maxHeight:E,metadata:T}=d.userData;return e.boundingVolume.region[4]=m,e.boundingVolume.region[5]=E,e.cached.boundingVolume.setRegionData(p,...e.boundingVolume.region),T&&("geometricerror"in T&&(e.geometricError=T.geometricerror),dt(e,this.layer)&&"available"in T&&e.children.length===0&&(e[tt]=[...new Array(e[st]+1).fill(null),...T.available])),this.expandChildren(e),d}getAttributions(t){this.attribution&&t.push(this.attribution)}createChild(t,e,s,n){const{tiles:i,layer:c,tiling:b,projection:l}=this,p=i.ellipsoid,d=n===null&&t===0||se(n,t,e,s),m=ie(e,s,t,1,c),E=[...b.getTileBounds(e,s,t),-at,at],[,T,,h,,L]=E,v=T>0!=h>0?0:Math.min(Math.abs(T),Math.abs(h));p.getCartographicToPosition(v,0,L,_t),_t.z=0;const y=l.tileCountX,o=Math.max(...p.radius)*2*Math.PI*.25/(65*y)/2**t,g={[tt]:null,[st]:t,[Tt]:e,[vt]:s,refine:"REPLACE",geometricError:o,boundingVolume:{region:E},content:d?{uri:m}:null,children:[]};return dt(g,c)||(g[tt]=n),g}expandChildren(t){const e=t[st],s=t[Tt],n=t[vt],i=t[tt];if(e>=this.tiling.maxLevel)return;let c=!1;for(let b=0;b<2;b++)for(let l=0;l<2;l++){const p=this.createChild(e+1,2*s+b,2*n+l,i);p.content!==null?(t.children.push(p),c=!0):(t.children.push(p),p.content={uri:`tile.quantized_tile_split?bottom=${l===0}&left=${b===0}`})}c||(t.children.length=0)}fetchData(t,e){if(/quantized_tile_split/.test(t))return new ArrayBuffer}disposeTile(t){dt(t,this.layer)&&(t[tt]=null),tt in t&&(t.children.forEach(e=>{this.tiles.processNodeQueue.remove(e)}),t.children.length=0,t.__childrenProcessed=0)}}let re=class extends Yt{constructor(t={}){super({assetTypeHandler:(e,s,n)=>{e==="TERRAIN"&&s.getPluginByName("QUANTIZED_MESH_PLUGIN")===null?(console.warn('CesiumIonAuthPlugin: CesiumIonAuthPlugin plugin auto-registration has been deprecated. Please implement a custom "assetTypeHandler" for "TERRAIN" using "QuantizedMeshPlugin", instead.'),s.registerPlugin(new oe({useRecommendedSettings:this.useRecommendedSettings}))):e==="IMAGERY"&&s.getPluginByName("TMS_TILES_PLUGIN")===null?(console.warn('CesiumIonAuthPlugin: CesiumIonAuthPlugin plugin auto-registration has been deprecated. Please implement a custom "assetTypeHandler" for "IMAGERY" using "TMSTilesPlugin", instead.'),s.registerPlugin(new Ut({useRecommendedSettings:this.useRecommendedSettings,shape:"ellipsoid"}))):console.warn(`CesiumIonAuthPlugin: Cesium Ion asset type "${e}" unhandled.`)},...t}),t.__suppress_warning__&&console.warn('CesiumIonAuthPlugin: Plugin has been moved to "3d-tiles-renderer/core/plugins".')}};class ye extends re{constructor(t){super({...t,__suppress_warning__:!0})}}export{ye as C};
//# sourceMappingURL=plugins-C5YAiOZ9.js.map
