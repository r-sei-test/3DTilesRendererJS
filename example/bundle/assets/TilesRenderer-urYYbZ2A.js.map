{"version":3,"file":"TilesRenderer-urYYbZ2A.js","sources":["../../../src/core/renderer/utilities/urlExtension.js","../../../src/core/renderer/utilities/LRUCache.js","../../../src/core/renderer/utilities/PriorityQueue.js","../../../src/core/renderer/tiles/traverseFunctions.js","../../../src/core/renderer/utilities/throttle.js","../../../src/core/renderer/utilities/TraversalUtils.js","../../../src/core/renderer/tiles/TilesRendererBase.js","../../../src/three/renderer/tiles/TilesGroup.js","../../../src/three/renderer/tiles/raycastTraverse.js","../../../src/three/renderer/math/OBB.js","../../../src/three/renderer/math/TileBoundingVolume.js","../../../src/three/renderer/math/ExtendedFrustum.js","../../../src/three/renderer/utils/MemoryUtils.js","../../../src/three/renderer/tiles/TilesRenderer.js"],"sourcesContent":["/**\n * Returns the file extension of the path component of a URL\n * @param {string} url\n * @returns {string} null if no extension found\n */\nexport function getUrlExtension( url ) {\n\n\tif ( ! url ) {\n\n\t\treturn null;\n\n\t}\n\n\t// Find the last occurrence of '?' and '#' to handle query params and fragments\n\tlet endIndex = url.length;\n\tconst queryIndex = url.indexOf( '?' );\n\tconst fragmentIndex = url.indexOf( '#' );\n\tif ( queryIndex !== - 1 ) {\n\n\t\tendIndex = Math.min( endIndex, queryIndex );\n\n\t}\n\n\tif ( fragmentIndex !== - 1 ) {\n\n\t\tendIndex = Math.min( endIndex, fragmentIndex );\n\n\t}\n\n\t// Check if the string is just a hostname or whether the path does not end in an extension\n\tconst lastPeriodIndex = url.lastIndexOf( '.', endIndex );\n\tconst lastSlashIndex = url.lastIndexOf( '/', endIndex );\n\tconst protocolIndex = url.indexOf( '://' );\n\tconst isHostOnly = protocolIndex !== - 1 && protocolIndex + 2 === lastSlashIndex;\n\tif ( isHostOnly || lastPeriodIndex === - 1 || lastPeriodIndex < lastSlashIndex ) {\n\n\t\treturn null;\n\n\t}\n\n\treturn url.substring( lastPeriodIndex + 1, endIndex ) || null;\n\n}\n","const GIGABYTE_BYTES = 2 ** 30;\n\nclass LRUCache {\n\n\tget unloadPriorityCallback() {\n\n\t\treturn this._unloadPriorityCallback;\n\n\t}\n\n\tset unloadPriorityCallback( cb ) {\n\n\t\tif ( cb.length === 1 ) {\n\n\t\t\tconsole.warn( 'LRUCache: \"unloadPriorityCallback\" function has been changed to take two arguments.' );\n\t\t\tthis._unloadPriorityCallback = ( a, b ) => {\n\n\t\t\t\tconst valA = cb( a );\n\t\t\t\tconst valB = cb( b );\n\n\t\t\t\tif ( valA < valB ) return - 1;\n\t\t\t\tif ( valA > valB ) return 1;\n\t\t\t\treturn 0;\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tthis._unloadPriorityCallback = cb;\n\n\t\t}\n\n\t}\n\n\tconstructor() {\n\n\t\t// options\n\t\tthis.minSize = 6000;\n\t\tthis.maxSize = 8000;\n\t\tthis.minBytesSize = 0.3 * GIGABYTE_BYTES;\n\t\tthis.maxBytesSize = 0.4 * GIGABYTE_BYTES;\n\t\tthis.unloadPercent = 0.05;\n\t\tthis.autoMarkUnused = true;\n\n\t\t// \"itemSet\" doubles as both the list of the full set of items currently\n\t\t// stored in the cache (keys) as well as a map to the time the item was last\n\t\t// used so it can be sorted appropriately.\n\t\tthis.itemSet = new Map();\n\t\tthis.itemList = [];\n\t\tthis.usedSet = new Set();\n\t\tthis.callbacks = new Map();\n\t\tthis.unloadingHandle = - 1;\n\t\tthis.cachedBytes = 0;\n\t\tthis.bytesMap = new Map();\n\t\tthis.loadedSet = new Set();\n\n\t\tthis._unloadPriorityCallback = null;\n\n\t\tconst itemSet = this.itemSet;\n\t\tthis.defaultPriorityCallback = item => itemSet.get( item );\n\n\t}\n\n\t// Returns whether or not the cache has reached the maximum size\n\tisFull() {\n\n\t\treturn this.itemSet.size >= this.maxSize || this.cachedBytes >= this.maxBytesSize;\n\n\t}\n\n\tgetMemoryUsage( item ) {\n\n\t\treturn this.bytesMap.get( item ) || 0;\n\n\t}\n\n\tsetMemoryUsage( item, bytes ) {\n\n\t\tconst { bytesMap, itemSet } = this;\n\t\tif ( ! itemSet.has( item ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\t\tbytesMap.set( item, bytes );\n\t\tthis.cachedBytes += bytes;\n\n\t}\n\n\tadd( item, removeCb ) {\n\n\t\tconst itemSet = this.itemSet;\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( this.isFull() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst usedSet = this.usedSet;\n\t\tconst itemList = this.itemList;\n\t\tconst callbacks = this.callbacks;\n\t\titemList.push( item );\n\t\tusedSet.add( item );\n\t\titemSet.set( item, Date.now() );\n\t\tcallbacks.set( item, removeCb );\n\n\t\treturn true;\n\n\t}\n\n\thas( item ) {\n\n\t\treturn this.itemSet.has( item );\n\n\t}\n\n\tremove( item ) {\n\n\t\tconst usedSet = this.usedSet;\n\t\tconst itemSet = this.itemSet;\n\t\tconst itemList = this.itemList;\n\t\tconst bytesMap = this.bytesMap;\n\t\tconst callbacks = this.callbacks;\n\t\tconst loadedSet = this.loadedSet;\n\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\t\t\tbytesMap.delete( item );\n\n\t\t\tcallbacks.get( item )( item );\n\n\t\t\tconst index = itemList.indexOf( item );\n\t\t\titemList.splice( index, 1 );\n\t\t\tusedSet.delete( item );\n\t\t\titemSet.delete( item );\n\t\t\tcallbacks.delete( item );\n\t\t\tloadedSet.delete( item );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// Marks whether tiles in the cache have been completely loaded or not. Tiles that have not been completely\n\t// loaded are subject to being disposed early if the cache is full above its max size limits, even if they\n\t// are marked as used.\n\tsetLoaded( item, value ) {\n\n\t\tconst { itemSet, loadedSet } = this;\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\tif ( value === true ) {\n\n\t\t\t\tloadedSet.add( item );\n\n\t\t\t} else {\n\n\t\t\t\tloadedSet.delete( item );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tmarkUsed( item ) {\n\n\t\tconst itemSet = this.itemSet;\n\t\tconst usedSet = this.usedSet;\n\t\tif ( itemSet.has( item ) && ! usedSet.has( item ) ) {\n\n\t\t\titemSet.set( item, Date.now() );\n\t\t\tusedSet.add( item );\n\n\t\t}\n\n\t}\n\n\tmarkUnused( item ) {\n\n\t\tthis.usedSet.delete( item );\n\n\t}\n\n\tmarkAllUnused() {\n\n\t\tthis.usedSet.clear();\n\n\t}\n\n\t// TODO: this should be renamed because it's not necessarily unloading all unused content\n\t// Maybe call it \"cleanup\" or \"unloadToMinSize\"\n\tunloadUnusedContent() {\n\n\t\tconst {\n\t\t\tunloadPercent,\n\t\t\tminSize,\n\t\t\tmaxSize,\n\t\t\titemList,\n\t\t\titemSet,\n\t\t\tusedSet,\n\t\t\tloadedSet,\n\t\t\tcallbacks,\n\t\t\tbytesMap,\n\t\t\tminBytesSize,\n\t\t\tmaxBytesSize,\n\t\t} = this;\n\n\t\tconst unused = itemList.length - usedSet.size;\n\t\tconst unloaded = itemList.length - loadedSet.size;\n\t\tconst excessNodes = Math.max( Math.min( itemList.length - minSize, unused ), 0 );\n\t\tconst excessBytes = this.cachedBytes - minBytesSize;\n\t\tconst unloadPriorityCallback = this.unloadPriorityCallback || this.defaultPriorityCallback;\n\t\tlet needsRerun = false;\n\n\t\tconst hasNodesToUnload = excessNodes > 0 && unused > 0 || unloaded && itemList.length > maxSize;\n\t\tconst hasBytesToUnload = unused && this.cachedBytes > minBytesSize || unloaded && this.cachedBytes > maxBytesSize;\n\t\tif ( hasBytesToUnload || hasNodesToUnload ) {\n\n\t\t\t// used items should be at the end of the array, \"unloaded\" items in the middle of the array\n\t\t\titemList.sort( ( a, b ) => {\n\n\t\t\t\tconst usedA = usedSet.has( a );\n\t\t\t\tconst usedB = usedSet.has( b );\n\t\t\t\tif ( usedA === usedB ) {\n\n\t\t\t\t\tconst loadedA = loadedSet.has( a );\n\t\t\t\t\tconst loadedB = loadedSet.has( b );\n\t\t\t\t\tif ( loadedA === loadedB ) {\n\n\t\t\t\t\t\t// Use the sort function otherwise\n\t\t\t\t\t\t// higher priority should be further to the left\n\t\t\t\t\t\treturn - unloadPriorityCallback( a, b );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn loadedA ? 1 : - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If one is used and the other is not move the used one towards the end of the array\n\t\t\t\t\treturn usedA ? 1 : - 1;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// address corner cases where the minSize might be zero or smaller than maxSize - minSize,\n\t\t\t// which would result in a very small or no items being unloaded.\n\t\t\tconst maxUnload = Math.max( minSize * unloadPercent, excessNodes * unloadPercent );\n\t\t\tconst nodesToUnload = Math.ceil( Math.min( maxUnload, unused, excessNodes ) );\n\t\t\tconst maxBytesUnload = Math.max( unloadPercent * excessBytes, unloadPercent * minBytesSize );\n\t\t\tconst bytesToUnload = Math.min( maxBytesUnload, excessBytes );\n\n\t\t\tlet removedNodes = 0;\n\t\t\tlet removedBytes = 0;\n\n\t\t\t// evict up to the max node or bytes size, keeping one more item over the max bytes limit\n\t\t\t// so the \"full\" function behaves correctly.\n\t\t\twhile (\n\t\t\t\tthis.cachedBytes - removedBytes > maxBytesSize ||\n\t\t\t\titemList.length - removedNodes > maxSize\n\t\t\t) {\n\n\t\t\t\tconst item = itemList[ removedNodes ];\n\t\t\t\tconst bytes = bytesMap.get( item ) || 0;\n\t\t\t\tif (\n\t\t\t\t\tusedSet.has( item ) && loadedSet.has( item ) ||\n\t\t\t\t\tthis.cachedBytes - removedBytes - bytes < maxBytesSize &&\n\t\t\t\t\titemList.length - removedNodes <= maxSize\n\t\t\t\t) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tremovedBytes += bytes;\n\t\t\t\tremovedNodes ++;\n\n\t\t\t}\n\n\t\t\t// evict up to the min node or bytes size, keeping one more item over the min bytes limit\n\t\t\t// so we're meeting it\n\t\t\twhile (\n\t\t\t\tremovedBytes < bytesToUnload ||\n\t\t\t\tremovedNodes < nodesToUnload\n\t\t\t) {\n\n\t\t\t\tconst item = itemList[ removedNodes ];\n\t\t\t\tconst bytes = bytesMap.get( item ) || 0;\n\t\t\t\tif (\n\t\t\t\t\tusedSet.has( item ) ||\n\t\t\t\t\tthis.cachedBytes - removedBytes - bytes < minBytesSize &&\n\t\t\t\t\tremovedNodes >= nodesToUnload\n\t\t\t\t) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tremovedBytes += bytes;\n\t\t\t\tremovedNodes ++;\n\n\t\t\t}\n\n\t\t\t// remove the nodes\n\t\t\titemList.splice( 0, removedNodes ).forEach( item => {\n\n\t\t\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\n\t\t\t\tcallbacks.get( item )( item );\n\t\t\t\tbytesMap.delete( item );\n\t\t\t\titemSet.delete( item );\n\t\t\t\tcallbacks.delete( item );\n\t\t\t\tloadedSet.delete( item );\n\t\t\t\tusedSet.delete( item );\n\n\t\t\t} );\n\n\t\t\t// if we didn't remove enough nodes or we still have excess bytes and there are nodes to removed\n\t\t\t// then we want to fire another round of unloading\n\t\t\tneedsRerun = removedNodes < excessNodes || removedBytes < excessBytes && removedNodes < unused;\n\t\t\tneedsRerun = needsRerun && removedNodes > 0;\n\n\t\t}\n\n\t\tif ( needsRerun ) {\n\n\t\t\tthis.unloadingHandle = requestAnimationFrame( () => this.scheduleUnload() );\n\n\t\t}\n\n\t}\n\n\tscheduleUnload() {\n\n\t\tcancelAnimationFrame( this.unloadingHandle );\n\n\t\tif ( ! this.scheduled ) {\n\n\t\t\tthis.scheduled = true;\n\t\t\tqueueMicrotask( () => {\n\n\t\t\t\tthis.scheduled = false;\n\t\t\t\tthis.unloadUnusedContent();\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LRUCache };\n","class PriorityQueue {\n\n\t// returns whether tasks are queued or actively running\n\tget running() {\n\n\t\treturn this.items.length !== 0 || this.currJobs !== 0;\n\n\t}\n\n\tconstructor() {\n\n\t\t// options\n\t\tthis.maxJobs = 6;\n\n\t\tthis.items = [];\n\t\tthis.callbacks = new Map();\n\t\tthis.currJobs = 0;\n\t\tthis.scheduled = false;\n\t\tthis.autoUpdate = true;\n\n\t\tthis.priorityCallback = null;\n\n\t\t// Customizable scheduling callback. Default using requestAnimationFrame()\n\t\tthis.schedulingCallback = func => {\n\n\t\t\trequestAnimationFrame( func );\n\n\t\t};\n\n\t\tthis._runjobs = () => {\n\n\t\t\tthis.scheduled = false;\n\t\t\tthis.tryRunJobs();\n\n\t\t};\n\n\t}\n\n\tsort() {\n\n\t\tconst priorityCallback = this.priorityCallback;\n\t\tconst items = this.items;\n\t\tif ( priorityCallback !== null ) {\n\n\t\t\titems.sort( priorityCallback );\n\n\t\t}\n\n\t}\n\n\thas( item ) {\n\n\t\treturn this.callbacks.has( item );\n\n\t}\n\n\tadd( item, callback ) {\n\n\t\tconst data = {\n\t\t\tcallback,\n\t\t\treject: null,\n\t\t\tresolve: null,\n\t\t\tpromise: null,\n\t\t};\n\n\t\tdata.promise = new Promise( ( resolve, reject ) => {\n\n\t\t\tconst items = this.items;\n\t\t\tconst callbacks = this.callbacks;\n\n\t\t\tdata.resolve = resolve;\n\t\t\tdata.reject = reject;\n\n\t\t\titems.unshift( item );\n\t\t\tcallbacks.set( item, data );\n\n\t\t\tif ( this.autoUpdate ) {\n\n\t\t\t\tthis.scheduleJobRun();\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn data.promise;\n\n\t}\n\n\tremove( item ) {\n\n\t\tconst items = this.items;\n\t\tconst callbacks = this.callbacks;\n\n\t\tconst index = items.indexOf( item );\n\t\tif ( index !== - 1 ) {\n\n\t\t\t// reject the promise to ensure there are no dangling promises - add a\n\t\t\t// catch here to handle the case where the promise was never used anywhere\n\t\t\t// else.\n\t\t\tconst info = callbacks.get( item );\n\t\t\tinfo.promise.catch( () => {} );\n\t\t\tinfo.reject( new Error( 'PriorityQueue: Item removed.' ) );\n\n\t\t\titems.splice( index, 1 );\n\t\t\tcallbacks.delete( item );\n\n\t\t}\n\n\t}\n\n\tremoveByFilter( filter ) {\n\n\t\tconst { items } = this;\n\t\tfor ( let i = 0; i < items.length; i ++ ) {\n\n\t\t\tconst item = items[ i ];\n\t\t\tif ( filter( item ) ) {\n\n\t\t\t\tthis.remove( item );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttryRunJobs() {\n\n\t\tthis.sort();\n\n\t\tconst items = this.items;\n\t\tconst callbacks = this.callbacks;\n\t\tconst maxJobs = this.maxJobs;\n\t\tlet iterated = 0;\n\n\t\tconst completedCallback = () => {\n\n\t\t\tthis.currJobs --;\n\n\t\t\tif ( this.autoUpdate ) {\n\n\t\t\t\tthis.scheduleJobRun();\n\n\t\t\t}\n\n\t\t};\n\n\t\twhile ( maxJobs > this.currJobs && items.length > 0 && iterated < maxJobs ) {\n\n\t\t\tthis.currJobs ++;\n\t\t\titerated ++;\n\t\t\tconst item = items.pop();\n\t\t\tconst { callback, resolve, reject } = callbacks.get( item );\n\t\t\tcallbacks.delete( item );\n\n\t\t\tlet result;\n\t\t\ttry {\n\n\t\t\t\tresult = callback( item );\n\n\t\t\t} catch ( err ) {\n\n\t\t\t\treject( err );\n\t\t\t\tcompletedCallback();\n\n\t\t\t}\n\n\t\t\tif ( result instanceof Promise ) {\n\n\t\t\t\tresult\n\t\t\t\t\t.then( resolve )\n\t\t\t\t\t.catch( reject )\n\t\t\t\t\t.finally( completedCallback );\n\n\t\t\t} else {\n\n\t\t\t\tresolve( result );\n\t\t\t\tcompletedCallback();\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tscheduleJobRun() {\n\n\t\tif ( ! this.scheduled ) {\n\n\t\t\tthis.schedulingCallback( this._runjobs );\n\n\t\t\tthis.scheduled = true;\n\n\t\t}\n\n\t}\n\n}\n\nexport { PriorityQueue };\n","import { LOADED, FAILED } from '../constants.js';\n\nconst viewErrorTarget = {\n\tinView: false,\n\terror: Infinity,\n\tdistanceFromCamera: Infinity,\n};\n\n// flag guiding the behavior of the traversal to load the siblings at the root of the\n// tileset or not. The spec seems to indicate \"true\" when using REPLACE define but\n// Cesium's behavior is \"false\".\n// See CesiumGS/3d-tiles#776\nconst LOAD_ROOT_SIBLINGS = true;\n\nfunction isDownloadFinished( value ) {\n\n\treturn value === LOADED || value === FAILED;\n\n}\n\n// Checks whether this tile was last used on the given frame.\nfunction isUsedThisFrame( tile, frameCount ) {\n\n\treturn tile.__lastFrameVisited === frameCount && tile.__used;\n\n}\n\nfunction areChildrenProcessed( tile ) {\n\n\treturn tile.__childrenProcessed === tile.children.length;\n\n}\n\nfunction canUnconditionallyRefine( tile ) {\n\n\treturn tile.__hasUnrenderableContent || ( tile.parent && tile.parent.geometricError < tile.geometricError );\n\n}\n\n// Resets the frame information for the given tile\nfunction resetFrameState( tile, renderer ) {\n\n\tif ( tile.__lastFrameVisited !== renderer.frameCount ) {\n\n\t\ttile.__lastFrameVisited = renderer.frameCount;\n\t\ttile.__used = false;\n\t\ttile.__inFrustum = false;\n\t\ttile.__isLeaf = false;\n\t\ttile.__visible = false;\n\t\ttile.__active = false;\n\t\ttile.__error = Infinity;\n\t\ttile.__distanceFromCamera = Infinity;\n\t\ttile.__allChildrenReady = false;\n\n\t\t// update tile frustum and error state\n\t\trenderer.calculateTileViewError( tile, viewErrorTarget );\n\t\ttile.__inFrustum = viewErrorTarget.inView;\n\t\ttile.__error = viewErrorTarget.error;\n\t\ttile.__distanceFromCamera = viewErrorTarget.distanceFromCamera;\n\n\t}\n\n}\n\n// Recursively mark tiles used down to the next layer, skipping external tilesets\nfunction recursivelyMarkUsed( tile, renderer, cacheOnly = false ) {\n\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\tresetFrameState( tile, renderer );\n\tmarkUsed( tile, renderer, cacheOnly );\n\n\t// don't traverse if the children have not been processed, yet but tileset content\n\t// should be considered to be \"replaced\" by the loaded children so await that here.\n\tif ( canUnconditionallyRefine( tile ) && areChildrenProcessed( tile ) ) {\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer, cacheOnly );\n\n\t\t}\n\n\t}\n\n}\n\n// Recursively traverses to the next tiles with unloaded renderable content to load them\nfunction recursivelyLoadNextRenderableTiles( tile, renderer ) {\n\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\t// exit the recursion if the tile hasn't been used this frame\n\tif ( isUsedThisFrame( tile, renderer.frameCount ) ) {\n\n\t\t// queue this tile to download content\n\t\tif ( tile.__hasContent ) {\n\n\t\t\trenderer.queueTileForDownload( tile );\n\n\t\t}\n\n\t\tif ( areChildrenProcessed( tile ) ) {\n\n\t\t\t// queue any used child tiles\n\t\t\tconst children = tile.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\trecursivelyLoadNextRenderableTiles( children[ i ], renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// Mark a tile as being used by current view\nfunction markUsed( tile, renderer, cacheOnly = false ) {\n\n\tif ( tile.__used ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( ! cacheOnly ) {\n\n\t\ttile.__used = true;\n\t\trenderer.stats.used ++;\n\n\t}\n\n\trenderer.markTileUsed( tile );\n\n\tif ( tile.__inFrustum === true ) {\n\n\t\trenderer.stats.inFrustum ++;\n\n\t}\n\n}\n\n// Returns whether the tile can be traversed to the next layer of children by checking the tile metrics\nfunction canTraverse( tile, renderer ) {\n\n\t// If we've met the error requirements then don't load further - if an external tileset is encountered,\n\t// though, then continue to refine.\n\tif ( tile.__error <= renderer.errorTarget && ! canUnconditionallyRefine( tile ) ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if we've reached the maximum allowed depth.\n\tif ( renderer.maxDepth > 0 && tile.__depth + 1 >= renderer.maxDepth ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if the children haven't been processed, yet\n\tif ( ! areChildrenProcessed( tile ) ) {\n\n\t\treturn false;\n\n\t}\n\n\treturn true;\n\n}\n\n// Determine which tiles are used by the renderer given the current camera configuration\nexport function markUsedTiles( tile, renderer ) {\n\n\t// determine frustum set is run first so we can ensure the preprocessing of all the necessary\n\t// child tiles has happened here.\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\tresetFrameState( tile, renderer );\n\n\tif ( ! tile.__inFrustum ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( ! canTraverse( tile, renderer ) ) {\n\n\t\tmarkUsed( tile, renderer );\n\t\treturn;\n\n\t}\n\n\t// Traverse children and see if any children are in view.\n\tlet anyChildrenUsed = false;\n\tlet anyChildrenInFrustum = false;\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tmarkUsedTiles( c, renderer );\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, renderer.frameCount );\n\t\tanyChildrenInFrustum = anyChildrenInFrustum || c.__inFrustum;\n\n\t}\n\n\t// If none of the children are visible in the frustum then there should be no reason to display this tile. We still mark\n\t// this tile and all children as \"used\" only in the cache (but not loaded) so they are not disposed, causing an oscillation\n\t// / flicker in the content.\n\tif ( tile.refine === 'REPLACE' && ! anyChildrenInFrustum && children.length !== 0 ) {\n\n\t\ttile.__inFrustum = false;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer, true );\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\t// wait until after the above condition to mark the traversed tile as used or not\n\tmarkUsed( tile, renderer );\n\n\t// If this is a tile that needs children loaded to refine then recursively load child\n\t// tiles until error is met\n\tif ( tile.refine === 'REPLACE' && ( anyChildrenUsed && tile.__depth !== 0 || LOAD_ROOT_SIBLINGS ) ) {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Traverse and mark the tiles that are at the leaf nodes of the \"used\" tree.\nexport function markUsedSetLeaves( tile, renderer ) {\n\n\tconst frameCount = renderer.frameCount;\n\tif ( ! isUsedThisFrame( tile, frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// This tile is a leaf if none of the children had been used.\n\tconst children = tile.children;\n\tlet anyChildrenUsed = false;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, frameCount );\n\n\t}\n\n\tif ( ! anyChildrenUsed ) {\n\n\t\ttile.__isLeaf = true;\n\n\t} else {\n\n\t\tlet allChildrenReady = true;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\tmarkUsedSetLeaves( c, renderer );\n\n\t\t\tif ( isUsedThisFrame( c, frameCount ) ) {\n\n\t\t\t\t// Compute whether this child is _allowed_ to display by checking the geometric error relative to the parent tile to avoid holes.\n\t\t\t\t// If the child's geometric error is less than or equal to the parent's (or it has unrenderable content), we should NOT display the child to avoid holes.\n\t\t\t\t// Only display the child if its geometric error is greater than the parent's and it has renderable content.\n\t\t\t\t// Note that this behavior is undocumented in the 3d tiles specification and tilesets designed to take advantage of it may not work as expected\n\t\t\t\t// in other rendering systems.\n\t\t\t\t// See issue NASA-AMMOS/3DTilesRendererJS#1304\n\t\t\t\tconst childCanDisplay = ! canUnconditionallyRefine( c );\n\n\t\t\t\t// Consider a child to be ready to be displayed if\n\t\t\t\t// - the children's children have been loaded\n\t\t\t\t// - the tile content has loaded\n\t\t\t\t// - the tile is completely empty - ie has no children and no content\n\t\t\t\t// - the child tileset has tried to load but failed\n\t\t\t\tlet isChildReady =\n\t\t\t\t\t! c.__hasContent ||\n\t\t\t\t\t( c.__hasRenderableContent && isDownloadFinished( c.__loadingState ) ) ||\n\t\t\t\t\t( c.__hasUnrenderableContent && c.__loadingState === FAILED );\n\n\t\t\t\t// Consider this child ready if it can be displayed and is ready for display or all of it's children ready to be displayed\n\t\t\t\tisChildReady = ( childCanDisplay && isChildReady ) || c.__allChildrenReady;\n\n\t\t\t\tallChildrenReady = allChildrenReady && isChildReady;\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.__allChildrenReady = allChildrenReady;\n\n\t}\n\n}\n\n// TODO: revisit implementation\n// Skip past tiles we consider unrenderable because they are outside the error threshold.\nexport function markVisibleTiles( tile, renderer ) {\n\n\tconst stats = renderer.stats;\n\tif ( ! isUsedThisFrame( tile, renderer.frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// Request the tile contents or mark it as visible if we've found a leaf.\n\tif ( tile.__isLeaf ) {\n\n\t\tif ( tile.__loadingState === LOADED ) {\n\n\t\t\tif ( tile.__inFrustum ) {\n\n\t\t\t\ttile.__visible = true;\n\t\t\t\tstats.visible ++;\n\n\t\t\t}\n\n\t\t\ttile.__active = true;\n\t\t\tstats.active ++;\n\n\t\t} else if ( tile.__hasContent ) {\n\n\t\t\trenderer.queueTileForDownload( tile );\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\tconst children = tile.children;\n\tconst hasContent = tile.__hasContent;\n\tconst loadedContent = isDownloadFinished( tile.__loadingState ) && hasContent;\n\tconst errorRequirement = ( renderer.errorTarget + 1 ) * renderer.errorThreshold;\n\tconst meetsSSE = tile.__error <= errorRequirement;\n\tconst isAdditiveRefine = tile.refine === 'ADD';\n\n\t// TODO: the \"meetsSSE\" field can be removed when the \"errorThreshold\" field has been removed\n\n\t// Don't wait for all children tiles to load if this tileset has empty tiles at the root in order\n\t// to match Cesium's behavior\n\tconst allChildrenReady = tile.__allChildrenReady || ( tile.__depth === 0 && ! LOAD_ROOT_SIBLINGS );\n\n\t// If we've met the SSE requirements and we can load content then fire a fetch.\n\tif ( hasContent && ( meetsSSE || isAdditiveRefine ) ) {\n\n\t\trenderer.queueTileForDownload( tile );\n\n\t}\n\n\t// By this time only tiles that meet the screen space error requirements will be traversed. Only mark this\n\t// as visible if it's been loaded and not all children have loaded yet or it's an additive tile, meaning it needs\n\t// to display in addition to the children.\n\n\t// Skip the tile entirely if there's no content to load\n\tif ( meetsSSE && loadedContent && ! allChildrenReady || loadedContent && isAdditiveRefine ) {\n\n\t\tif ( tile.__inFrustum ) {\n\n\t\t\ttile.__visible = true;\n\t\t\tstats.visible ++;\n\n\t\t}\n\n\t\ttile.__active = true;\n\t\tstats.active ++;\n\n\t}\n\n\t// If we're additive then don't stop the traversal here because it doesn't matter whether the children load in\n\t// at the same rate.\n\tif ( ! isAdditiveRefine && meetsSSE && ! allChildrenReady ) {\n\n\t\t// load the child content if we've found that we've been loaded so we can move down to the next tile\n\t\t// layer when the data has loaded.\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\tif ( isUsedThisFrame( c, renderer.frameCount ) ) {\n\n\t\t\t\trecursivelyLoadNextRenderableTiles( c, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tmarkVisibleTiles( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Final traverse to toggle tile visibility.\nexport function toggleTiles( tile, renderer ) {\n\n\tconst isUsed = isUsedThisFrame( tile, renderer.frameCount );\n\tif ( isUsed || tile.__usedLastFrame ) {\n\n\t\tlet setActive = false;\n\t\tlet setVisible = false;\n\t\tif ( isUsed ) {\n\n\t\t\t// enable visibility if active due to shadows\n\t\t\tsetActive = tile.__active;\n\t\t\tif ( renderer.displayActiveTiles ) {\n\n\t\t\t\tsetVisible = tile.__active || tile.__visible;\n\n\t\t\t} else {\n\n\t\t\t\tsetVisible = tile.__visible;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// if the tile was used last frame but not this one then there's potential for the tile\n\t\t\t// to not have been visited during the traversal, meaning it hasn't been reset and has\n\t\t\t// stale values. This ensures the values are not stale.\n\t\t\tresetFrameState( tile, renderer );\n\n\t\t}\n\n\t\t// If the active or visible state changed then call the functions.\n\t\tif ( tile.__hasRenderableContent && tile.__loadingState === LOADED ) {\n\n\t\t\tif ( tile.__wasSetActive !== setActive ) {\n\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileActive && plugin.setTileActive( tile, setActive ) );\n\n\t\t\t}\n\n\t\t\tif ( tile.__wasSetVisible !== setVisible ) {\n\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileVisible && plugin.setTileVisible( tile, setVisible ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.__wasSetActive = setActive;\n\t\ttile.__wasSetVisible = setVisible;\n\t\ttile.__usedLastFrame = isUsed;\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\ttoggleTiles( c, renderer );\n\n\t\t}\n\n\t}\n\n}\n","// function that rate limits the amount of time a function can be called to once\n// per frame, initially queuing a new call for the next frame.\nexport function throttle( callback ) {\n\n\tlet handle = null;\n\treturn () => {\n\n\t\tif ( handle === null ) {\n\n\t\t\thandle = requestAnimationFrame( () => {\n\n\t\t\t\thandle = null;\n\t\t\t\tcallback();\n\n\t\t\t} );\n\n\t\t}\n\n\t};\n\n}\n","// Helper function for traversing a tileset. If `beforeCb` returns `true` then the\n// traversal will end early.\nexport function traverseSet( tile, beforeCb = null, afterCb = null ) {\n\n\tconst stack = [];\n\n\t// A stack-based, depth-first traversal, storing\n\t// triplets (tile, parent, depth) in the stack array.\n\n\tstack.push( tile );\n\tstack.push( null );\n\tstack.push( 0 );\n\n\twhile ( stack.length > 0 ) {\n\n\t\tconst depth = stack.pop();\n\t\tconst parent = stack.pop();\n\t\tconst tile = stack.pop();\n\n\t\tif ( beforeCb && beforeCb( tile, parent, depth ) ) {\n\n\t\t\tif ( afterCb ) {\n\n\t\t\t\tafterCb( tile, parent, depth );\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst children = tile.children;\n\n\t\t// Children might be undefined if the tile has not been preprocessed yet\n\t\tif ( children ) {\n\n\t\t\tfor ( let i = children.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tstack.push( children[ i ] );\n\t\t\t\tstack.push( tile );\n\t\t\t\tstack.push( depth + 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( afterCb ) {\n\n\t\t\tafterCb( tile, parent, depth );\n\n\t\t}\n\n\t}\n\n}\n\n// Traverses the ancestry of the tile up to the root tile.\nexport function traverseAncestors( tile, callback = null ) {\n\n\tlet current = tile;\n\n\twhile ( current ) {\n\n\t\tconst depth = current.__depth;\n\t\tconst parent = current.parent;\n\n\t\tif ( callback ) {\n\n\t\t\tcallback( current, parent, depth );\n\n\t\t}\n\n\t\tcurrent = parent;\n\n\t}\n\n\n}\n","import { getUrlExtension } from '../utilities/urlExtension.js';\nimport { LRUCache } from '../utilities/LRUCache.js';\nimport { PriorityQueue } from '../utilities/PriorityQueue.js';\nimport { markUsedTiles, toggleTiles, markVisibleTiles, markUsedSetLeaves } from './traverseFunctions.js';\nimport { UNLOADED, LOADING, PARSING, LOADED, FAILED } from '../constants.js';\nimport { throttle } from '../utilities/throttle.js';\nimport { traverseSet } from '../utilities/TraversalUtils.js';\n\nconst PLUGIN_REGISTERED = Symbol( 'PLUGIN_REGISTERED' );\n\n// priority queue sort function that takes two tiles to compare. Returning 1 means\n// \"tile a\" is loaded first.\nconst priorityCallback = ( a, b ) => {\n\n\tconst aPriority = a.priority || 0;\n\tconst bPriority = b.priority || 0;\n\n\tif ( aPriority !== bPriority ) {\n\n\t\t// lower priority value sorts first\n\t\treturn aPriority > bPriority ? 1 : - 1;\n\n\t} else if ( a.__used !== b.__used ) {\n\n\t\t// load tiles that have been used\n\t\treturn a.__used ? 1 : - 1;\n\n\t} else if ( a.__error !== b.__error ) {\n\n\t\t// load the tile with the higher error\n\t\treturn a.__error > b.__error ? 1 : - 1;\n\n\t} else if ( a.__distanceFromCamera !== b.__distanceFromCamera ) {\n\n\t\t// and finally visible tiles which have equal error (ex: if geometricError === 0)\n\t\t// should prioritize based on distance.\n\t\treturn a.__distanceFromCamera > b.__distanceFromCamera ? - 1 : 1;\n\n\t} else if ( a.__depthFromRenderedParent !== b.__depthFromRenderedParent ) {\n\n\t\treturn a.__depthFromRenderedParent > b.__depthFromRenderedParent ? - 1 : 1;\n\n\t}\n\n\treturn 0;\n\n};\n\n// lru cache unload callback that takes two tiles to compare. Returning 1 means \"tile a\"\n// is unloaded first.\nconst lruPriorityCallback = ( a, b ) => {\n\n\tconst aPriority = a.priority || 0;\n\tconst bPriority = b.priority || 0;\n\n\tif ( aPriority !== bPriority ) {\n\n\t\t// lower priority value sorts first\n\t\treturn aPriority > bPriority ? 1 : - 1;\n\n\t} else if ( a.__lastFrameVisited !== b.__lastFrameVisited ) {\n\n\t\t// dispose of least recent tiles first\n\t\treturn a.__lastFrameVisited > b.__lastFrameVisited ? - 1 : 1;\n\n\t} else if ( a.__depthFromRenderedParent !== b.__depthFromRenderedParent ) {\n\n\t\t// dispose of deeper tiles first so parents are not disposed before children\n\t\treturn a.__depthFromRenderedParent > b.__depthFromRenderedParent ? 1 : - 1;\n\n\t} else if ( a.__loadingState !== b.__loadingState ) {\n\n\t\t// dispose of tiles that are earlier along in the loading process first\n\t\treturn a.__loadingState > b.__loadingState ? - 1 : 1;\n\n\t} else if ( a.__hasUnrenderableContent !== b.__hasUnrenderableContent ) {\n\n\t\t// dispose of external tilesets last\n\t\treturn a.__hasUnrenderableContent ? - 1 : 1;\n\n\t} else if ( a.__error !== b.__error ) {\n\n\t\t// unload the tile with lower error\n\t\treturn a.__error > b.__error ? - 1 : 1;\n\n\t}\n\n\treturn 0;\n\n};\n\nexport class TilesRendererBase {\n\n\tget root() {\n\n\t\tconst tileset = this.rootTileset;\n\t\treturn tileset ? tileset.root : null;\n\n\t}\n\n\tget rootTileSet() {\n\n\t\tconsole.warn( 'TilesRenderer: \"rootTileSet\" has been deprecated. Use \"rootTileset\" instead.' );\n\t\treturn this.rootTileset;\n\n\t}\n\n\tget loadProgress() {\n\n\t\tconst { stats, isLoading } = this;\n\t\tconst loading = stats.downloading + stats.parsing;\n\t\tconst total = stats.inCacheSinceLoad + ( isLoading ? 1 : 0 );\n\t\treturn total === 0 ? 1.0 : 1.0 - loading / total;\n\n\t}\n\n\tget errorThreshold() {\n\n\t\treturn this._errorThreshold;\n\n\t}\n\n\tset errorThreshold( v ) {\n\n\t\tconsole.warn( 'TilesRenderer: The \"errorThreshold\" option has been deprecated.' );\n\t\tthis._errorThreshold = v;\n\n\t}\n\n\tconstructor( url = null ) {\n\n\t\t// state\n\t\tthis.rootLoadingState = UNLOADED;\n\t\tthis.rootTileset = null;\n\t\tthis.rootURL = url;\n\t\tthis.fetchOptions = {};\n\t\tthis.plugins = [];\n\t\tthis.queuedTiles = [];\n\t\tthis.cachedSinceLoadComplete = new Set();\n\t\tthis.isLoading = false;\n\n\t\tconst lruCache = new LRUCache();\n\t\tlruCache.unloadPriorityCallback = lruPriorityCallback;\n\n\t\tconst downloadQueue = new PriorityQueue();\n\t\tdownloadQueue.maxJobs = 25;\n\t\tdownloadQueue.priorityCallback = priorityCallback;\n\n\t\tconst parseQueue = new PriorityQueue();\n\t\tparseQueue.maxJobs = 5;\n\t\tparseQueue.priorityCallback = priorityCallback;\n\n\t\tconst processNodeQueue = new PriorityQueue();\n\t\tprocessNodeQueue.maxJobs = 25;\n\n\t\tthis.processedTiles = new WeakSet();\n\t\tthis.visibleTiles = new Set();\n\t\tthis.activeTiles = new Set();\n\t\tthis.usedSet = new Set();\n\t\tthis.lruCache = lruCache;\n\t\tthis.downloadQueue = downloadQueue;\n\t\tthis.parseQueue = parseQueue;\n\t\tthis.processNodeQueue = processNodeQueue;\n\t\tthis.stats = {\n\t\t\tinCacheSinceLoad: 0,\n\t\t\tinCache: 0,\n\t\t\tparsing: 0,\n\t\t\tdownloading: 0,\n\t\t\tfailed: 0,\n\t\t\tinFrustum: 0,\n\t\t\tused: 0,\n\t\t\tactive: 0,\n\t\t\tvisible: 0,\n\t\t};\n\t\tthis.frameCount = 0;\n\n\t\t// callbacks\n\t\tthis._dispatchNeedsUpdateEvent = throttle( () => {\n\n\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\n\t\t} );\n\n\t\t// options\n\t\tthis.errorTarget = 16.0;\n\t\tthis._errorThreshold = Infinity;\n\t\tthis.displayActiveTiles = false;\n\t\tthis.maxDepth = Infinity;\n\n\t}\n\n\t// Plugins\n\tregisterPlugin( plugin ) {\n\n\t\tif ( plugin[ PLUGIN_REGISTERED ] === true ) {\n\n\t\t\tthrow new Error( 'TilesRendererBase: A plugin can only be registered to a single tileset' );\n\n\t\t}\n\n\t\t// warn if plugin implements deprecated loadRootTileSet method\n\t\tif ( plugin.loadRootTileSet && ! plugin.loadRootTileset ) {\n\n\t\t\tconsole.warn( 'TilesRendererBase: Plugin implements deprecated \"loadRootTileSet\" method. Please rename to \"loadRootTileset\".' );\n\t\t\tplugin.loadRootTileset = plugin.loadRootTileSet;\n\n\t\t}\n\n\t\tif ( plugin.preprocessTileSet && ! plugin.preprocessTileset ) {\n\n\t\t\tconsole.warn( 'TilesRendererBase: Plugin implements deprecated \"preprocessTileSet\" method. Please rename to \"preprocessTileset\".' );\n\t\t\tplugin.preprocessTileset = plugin.preprocessTileSet;\n\n\t\t}\n\n\t\t// insert the plugin based on the priority registered on the plugin\n\t\tconst plugins = this.plugins;\n\t\tconst priority = plugin.priority || 0;\n\t\tlet insertionPoint = plugins.length;\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst otherPriority = plugins[ i ].priority || 0;\n\t\t\tif ( otherPriority > priority ) {\n\n\t\t\t\tinsertionPoint = i;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tplugins.splice( insertionPoint, 0, plugin );\n\t\tplugin[ PLUGIN_REGISTERED ] = true;\n\t\tif ( plugin.init ) {\n\n\t\t\tplugin.init( this );\n\n\t\t}\n\n\t}\n\n\tunregisterPlugin( plugin ) {\n\n\t\tconst plugins = this.plugins;\n\t\tif ( typeof plugin === 'string' ) {\n\n\t\t\tplugin = this.getPluginByName( plugin );\n\n\t\t}\n\n\t\tif ( plugins.includes( plugin ) ) {\n\n\t\t\tconst index = plugins.indexOf( plugin );\n\t\t\tplugins.splice( index, 1 );\n\t\t\tif ( plugin.dispose ) {\n\n\t\t\t\tplugin.dispose();\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetPluginByName( name ) {\n\n\t\treturn this.plugins.find( p => p.name === name ) || null;\n\n\t}\n\n\tinvokeOnePlugin( func ) {\n\n\t\tconst plugins = [ ...this.plugins, this ];\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst result = func( plugins[ i ] );\n\t\t\tif ( result ) {\n\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tinvokeAllPlugins( func ) {\n\n\t\tconst plugins = [ ...this.plugins, this ];\n\t\tconst pending = [];\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst result = func( plugins[ i ] );\n\t\t\tif ( result ) {\n\n\t\t\t\tpending.push( result );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn pending.length === 0 ? null : Promise.all( pending );\n\n\t}\n\n\t// Public API\n\ttraverse( beforecb, aftercb, ensureFullyProcessed = true ) {\n\n\t\tif ( ! this.root ) return;\n\n\t\ttraverseSet( this.root, ( tile, ...args ) => {\n\n\t\t\tif ( ensureFullyProcessed ) {\n\n\t\t\t\tthis.ensureChildrenArePreprocessed( tile, true );\n\n\t\t\t}\n\n\t\t\treturn beforecb ? beforecb( tile, ...args ) : false;\n\n\t\t}, aftercb );\n\n\t}\n\n\tgetAttributions( target = [] ) {\n\n\t\tthis.invokeAllPlugins( plugin => plugin !== this && plugin.getAttributions && plugin.getAttributions( target ) );\n\t\treturn target;\n\n\t}\n\n\tupdate() {\n\n\t\tconst { lruCache, usedSet, stats, root, downloadQueue, parseQueue, processNodeQueue } = this;\n\t\tif ( this.rootLoadingState === UNLOADED ) {\n\n\t\t\tthis.rootLoadingState = LOADING;\n\t\t\tthis.invokeOnePlugin( plugin => plugin.loadRootTileset && plugin.loadRootTileset() )\n\t\t\t\t.then( root => {\n\n\t\t\t\t\tlet processedUrl = this.rootURL;\n\t\t\t\t\tif ( processedUrl !== null ) {\n\n\t\t\t\t\t\tthis.invokeAllPlugins( plugin => processedUrl = plugin.preprocessURL ? plugin.preprocessURL( processedUrl, null ) : processedUrl );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.rootLoadingState = LOADED;\n\t\t\t\t\tthis.rootTileset = root;\n\t\t\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\t\t\t\t\tthis.dispatchEvent( { type: 'load-content' } );\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-tileset',\n\t\t\t\t\t\ttileset: root,\n\t\t\t\t\t\turl: processedUrl,\n\t\t\t\t\t} );\n\n\t\t\t\t} )\n\t\t\t\t.catch( error => {\n\n\t\t\t\t\tthis.rootLoadingState = FAILED;\n\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\tthis.rootTileset = null;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-error',\n\t\t\t\t\t\ttile: null,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\turl: this.rootURL,\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tif ( ! root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tstats.inFrustum = 0;\n\t\tstats.used = 0;\n\t\tstats.active = 0;\n\t\tstats.visible = 0;\n\t\tthis.frameCount ++;\n\n\t\tusedSet.forEach( tile => lruCache.markUnused( tile ) );\n\t\tusedSet.clear();\n\n\t\tmarkUsedTiles( root, this );\n\t\tmarkUsedSetLeaves( root, this );\n\t\tmarkVisibleTiles( root, this );\n\t\ttoggleTiles( root, this );\n\n\t\t// TODO: This will only sort for one tileset. We may want to store this queue on the\n\t\t// LRUCache so multiple tilesets can use it at once\n\t\t// start the downloads of the tiles as needed\n\t\tconst queuedTiles = this.queuedTiles;\n\t\tqueuedTiles.sort( lruCache.unloadPriorityCallback );\n\t\tfor ( let i = 0, l = queuedTiles.length; i < l && ! lruCache.isFull(); i ++ ) {\n\n\t\t\tthis.requestTileContents( queuedTiles[ i ] );\n\n\t\t}\n\n\t\tqueuedTiles.length = 0;\n\n\t\t// start the downloads\n\t\tlruCache.scheduleUnload();\n\n\t\t// if all tasks have finished and we've been marked as actively loading then fire the completion event\n\t\tconst runningTasks = downloadQueue.running || parseQueue.running || processNodeQueue.running;\n\t\tif ( runningTasks === false && this.isLoading === true ) {\n\n\t\t\tthis.cachedSinceLoadComplete.clear();\n\t\t\tstats.inCacheSinceLoad = 0;\n\n\t\t\tthis.dispatchEvent( { type: 'tiles-load-end' } );\n\t\t\tthis.isLoading = false;\n\n\t\t}\n\n\t}\n\n\tresetFailedTiles() {\n\n\t\t// reset the root tile if it's finished but never loaded\n\t\tif ( this.rootLoadingState === FAILED ) {\n\n\t\t\tthis.rootLoadingState = UNLOADED;\n\n\t\t}\n\n\t\tconst stats = this.stats;\n\t\tif ( stats.failed === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.traverse( tile => {\n\n\t\t\tif ( tile.__loadingState === FAILED ) {\n\n\t\t\t\ttile.__loadingState = UNLOADED;\n\n\t\t\t}\n\n\t\t}, null, false );\n\n\t\tstats.failed = 0;\n\n\t}\n\n\tdispose() {\n\n\t\t// dispose of all the plugins\n\t\tconst plugins = [ ...this.plugins ];\n\t\tplugins.forEach( plugin => {\n\n\t\t\tthis.unregisterPlugin( plugin );\n\n\t\t} );\n\n\t\tconst lruCache = this.lruCache;\n\n\t\t// Make sure we've collected all children before disposing of the internal tilesets to avoid\n\t\t// dangling children that we inadvertantly skip when deleting the nested tileset.\n\t\tconst toRemove = [];\n\t\tthis.traverse( t => {\n\n\t\t\ttoRemove.push( t );\n\t\t\treturn false;\n\n\t\t}, null, false );\n\t\tfor ( let i = 0, l = toRemove.length; i < l; i ++ ) {\n\n\t\t\tlruCache.remove( toRemove[ i ] );\n\n\t\t}\n\n\t\tthis.stats = {\n\t\t\tparsing: 0,\n\t\t\tdownloading: 0,\n\t\t\tfailed: 0,\n\t\t\tinFrustum: 0,\n\t\t\tused: 0,\n\t\t\tactive: 0,\n\t\t\tvisible: 0,\n\t\t};\n\t\tthis.frameCount = 0;\n\n\t}\n\n\t// Overrideable\n\tcalculateBytesUsed( scene, tile ) {\n\n\t\treturn 0;\n\n\t}\n\n\tdispatchEvent( e ) {}\n\n\taddEventListener( name, callback ) {}\n\n\tremoveEventListener( name, callback ) {}\n\n\tparseTile( buffer, tile, extension ) {\n\n\t\treturn null;\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\t// TODO: are these necessary? Are we disposing tiles when they are currently visible?\n\t\tif ( tile.__visible ) {\n\n\t\t\tthis.invokeOnePlugin( plugin => plugin.setTileVisible && plugin.setTileVisible( tile, false ) );\n\t\t\ttile.__visible = false;\n\n\t\t}\n\n\t\tif ( tile.__active ) {\n\n\t\t\tthis.invokeOnePlugin( plugin => plugin.setTileActive && plugin.setTileActive( tile, false ) );\n\t\t\ttile.__active = false;\n\n\t\t}\n\n\t}\n\n\tpreprocessNode( tile, tilesetDir, parentTile = null ) {\n\n\t\tthis.processedTiles.add( tile );\n\n\t\tif ( tile.content ) {\n\n\t\t\t// Fix old file formats\n\t\t\tif ( ! ( 'uri' in tile.content ) && 'url' in tile.content ) {\n\n\t\t\t\ttile.content.uri = tile.content.url;\n\t\t\t\tdelete tile.content.url;\n\n\t\t\t}\n\n\t\t\t// NOTE: fix for some cases where tilesets provide the bounding volume\n\t\t\t// but volumes are not present.\n\t\t\tif (\n\t\t\t\ttile.content.boundingVolume &&\n\t\t\t\t! (\n\t\t\t\t\t'box' in tile.content.boundingVolume ||\n\t\t\t\t\t'sphere' in tile.content.boundingVolume ||\n\t\t\t\t\t'region' in tile.content.boundingVolume\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t\tdelete tile.content.boundingVolume;\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.parent = parentTile;\n\t\ttile.children = tile.children || [];\n\n\t\tif ( tile.content?.uri ) {\n\n\t\t\t// \"content\" should only indicate loadable meshes, not external tilesets\n\t\t\tconst extension = getUrlExtension( tile.content.uri );\n\n\t\t\ttile.__hasContent = true;\n\t\t\ttile.__hasUnrenderableContent = Boolean( extension && /json$/.test( extension ) );\n\t\t\ttile.__hasRenderableContent = ! tile.__hasUnrenderableContent;\n\n\t\t} else {\n\n\t\t\ttile.__hasContent = false;\n\t\t\ttile.__hasUnrenderableContent = false;\n\t\t\ttile.__hasRenderableContent = false;\n\n\t\t}\n\n\t\t// tracker for determining if all the children have been asynchronously\n\t\t// processed and are ready to be traversed\n\t\ttile.__childrenProcessed = 0;\n\t\tif ( parentTile ) {\n\n\t\t\tparentTile.__childrenProcessed ++;\n\n\t\t}\n\n\t\ttile.__distanceFromCamera = Infinity;\n\t\ttile.__error = Infinity;\n\n\t\ttile.__inFrustum = false;\n\t\ttile.__isLeaf = false;\n\n\t\ttile.__usedLastFrame = false;\n\t\ttile.__used = false;\n\n\t\ttile.__wasSetVisible = false;\n\t\ttile.__visible = false;\n\t\ttile.__allChildrenReady = false;\n\n\t\ttile.__wasSetActive = false;\n\t\ttile.__active = false;\n\n\t\ttile.__loadingState = UNLOADED;\n\n\t\tif ( parentTile === null ) {\n\n\t\t\ttile.__depth = 0;\n\t\t\ttile.__depthFromRenderedParent = ( tile.__hasRenderableContent ? 1 : 0 );\n\t\t\ttile.refine = tile.refine || 'REPLACE';\n\n\t\t} else {\n\n\t\t\t// increment the \"depth from parent\" when we encounter a new tile with content\n\t\t\ttile.__depth = parentTile.__depth + 1;\n\t\t\ttile.__depthFromRenderedParent = parentTile.__depthFromRenderedParent + ( tile.__hasRenderableContent ? 1 : 0 );\n\n\t\t\ttile.refine = tile.refine || parentTile.refine;\n\n\t\t}\n\n\t\ttile.__basePath = tilesetDir;\n\n\t\ttile.__lastFrameVisited = - 1;\n\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tplugin !== this && plugin.preprocessNode && plugin.preprocessNode( tile, tilesetDir, parentTile );\n\n\t\t} );\n\n\t}\n\n\tsetTileActive( tile, active ) {\n\n\t\tactive ? this.activeTiles.add( tile ) : this.activeTiles.delete( tile );\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tvisible ? this.visibleTiles.add( tile ) : this.visibleTiles.delete( tile );\n\n\t}\n\n\tcalculateTileViewError( tile, target ) {\n\n\t\t// retrieve whether the tile is visible, screen space error, and distance to camera\n\t\t// set \"inView\", \"error\", \"distance\"\n\n\t}\n\n\t// Private Functions\n\tqueueTileForDownload( tile ) {\n\n\t\tif ( tile.__loadingState !== UNLOADED || this.lruCache.isFull() ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.queuedTiles.push( tile );\n\n\t}\n\n\tmarkTileUsed( tile ) {\n\n\t\t// save the tile in a separate \"used set\" so we can mark it as unused\n\t\t// before the next tileset traversal\n\t\tthis.usedSet.add( tile );\n\t\tthis.lruCache.markUsed( tile );\n\n\t}\n\n\tfetchData( url, options ) {\n\n\t\treturn fetch( url, options );\n\n\t}\n\n\tensureChildrenArePreprocessed( tile, immediate = false ) {\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst child = children[ i ];\n\t\t\tif ( '__depth' in child ) {\n\n\t\t\t\t// the child has already been processed\n\t\t\t\tbreak;\n\n\t\t\t} else if ( immediate ) {\n\n\t\t\t\t// process the node immediately and make sure we don't double process it\n\t\t\t\tthis.processNodeQueue.remove( child );\n\t\t\t\tthis.preprocessNode( child, tile.__basePath, tile );\n\n\t\t\t} else {\n\n\t\t\t\t// queue the node for processing if it hasn't been already\n\t\t\t\tif ( ! this.processNodeQueue.has( child ) ) {\n\n\t\t\t\t\tthis.processNodeQueue.add( child, child => {\n\n\t\t\t\t\t\tthis.preprocessNode( child, tile.__basePath, tile );\n\t\t\t\t\t\tthis._dispatchNeedsUpdateEvent();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// returns the total bytes used for by the given tile as reported by all plugins\n\tgetBytesUsed( tile ) {\n\n\t\tlet bytes = 0;\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin.calculateBytesUsed ) {\n\n\t\t\t\tbytes += plugin.calculateBytesUsed( tile, tile.cached.scene ) || 0;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn bytes;\n\n\t}\n\n\t// force a recalculation of the tile or all tiles if no tile is provided\n\trecalculateBytesUsed( tile = null ) {\n\n\t\tconst { lruCache, processedTiles } = this;\n\t\tif ( tile === null ) {\n\n\t\t\tlruCache.itemSet.forEach( item => {\n\n\t\t\t\tif ( processedTiles.has( item ) ) {\n\n\t\t\t\t\tlruCache.setMemoryUsage( item, this.getBytesUsed( item ) );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tlruCache.setMemoryUsage( tile, this.getBytesUsed( tile ) );\n\n\t\t}\n\n\t}\n\n\tpreprocessTileset( json, url, parent = null ) {\n\n\t\t// check for deprecated function usage\n\t\tconst proto = Object.getPrototypeOf( this );\n\t\tif ( Object.hasOwn( proto, 'preprocessTileSet' ) ) {\n\n\t\t\tconsole.warn( `${ proto.constructor.name }: Class overrides deprecated \"preprocessTileSet\" method. Please rename to \"preprocessTileset\".` );\n\n\t\t}\n\n\t\tconst version = json.asset.version;\n\t\tconst [ major, minor ] = version.split( '.' ).map( v => parseInt( v ) );\n\t\tconsole.assert(\n\t\t\tmajor <= 1,\n\t\t\t'TilesRenderer: asset.version is expected to be a 1.x or a compatible version.',\n\t\t);\n\n\t\tif ( major === 1 && minor > 0 ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.' );\n\n\t\t}\n\n\t\t// remove the last file path path-segment from the URL including the trailing slash\n\t\tlet basePath = url.replace( /\\/[^/]*$/, '' );\n\t\tbasePath = new URL( basePath, window.location.href ).toString();\n\t\tthis.preprocessNode( json.root, basePath, parent );\n\n\t}\n\n\tpreprocessTileSet( ...args ) {\n\n\t\tconsole.warn( 'TilesRenderer: \"preprocessTileSet\" has been deprecated. Use \"preprocessTileset\" instead.' );\n\t\treturn this.preprocessTileset( ...args );\n\n\t}\n\n\tloadRootTileset() {\n\n\t\t// check for deprecated function usage\n\t\tconst proto = Object.getPrototypeOf( this );\n\t\tif ( Object.hasOwn( proto, 'loadRootTileSet' ) ) {\n\n\t\t\tconsole.warn( `${ proto.constructor.name }: Class overrides deprecated \"loadRootTileSet\" method. Please rename to \"loadRootTileset\".` );\n\n\t\t}\n\n\t\t// transform the url\n\t\tlet processedUrl = this.rootURL;\n\t\tthis.invokeAllPlugins( plugin => processedUrl = plugin.preprocessURL ? plugin.preprocessURL( processedUrl, null ) : processedUrl );\n\n\t\t// load the tileset root\n\t\tconst pr = this\n\t\t\t.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( processedUrl, this.fetchOptions ) )\n\t\t\t.then( res => {\n\n\t\t\t\tif ( ! ( res instanceof Response ) ) {\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} else if ( res.ok ) {\n\n\t\t\t\t\treturn res.json();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `TilesRenderer: Failed to load tileset \"${ processedUrl }\" with status ${ res.status } : ${ res.statusText }` );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( root => {\n\n\t\t\t\tthis.preprocessTileset( root, processedUrl );\n\t\t\t\treturn root;\n\n\t\t\t} );\n\n\t\treturn pr;\n\n\t}\n\n\tloadRootTileSet( ...args ) {\n\n\t\tconsole.warn( 'TilesRenderer: \"loadRootTileSet\" has been deprecated. Use \"loadRootTileset\" instead.' );\n\t\treturn this.loadRootTileSet( ...args );\n\n\t}\n\n\trequestTileContents( tile ) {\n\n\t\t// If the tile is already being loaded then don't\n\t\t// start it again.\n\t\tif ( tile.__loadingState !== UNLOADED ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet isExternalTileset = false;\n\t\tlet externalTileset = null;\n\t\tlet uri = new URL( tile.content.uri, tile.__basePath + '/' ).toString();\n\t\tthis.invokeAllPlugins( plugin => uri = plugin.preprocessURL ? plugin.preprocessURL( uri, tile ) : uri );\n\n\t\tconst stats = this.stats;\n\t\tconst lruCache = this.lruCache;\n\t\tconst downloadQueue = this.downloadQueue;\n\t\tconst parseQueue = this.parseQueue;\n\t\tconst extension = getUrlExtension( uri );\n\n\t\t// track an abort controller and pass-through the below conditions if aborted\n\t\tconst controller = new AbortController();\n\t\tconst signal = controller.signal;\n\t\tconst addedSuccessfully = lruCache.add( tile, t => {\n\n\t\t\t// Stop the load if it's started\n\t\t\tcontroller.abort();\n\n\t\t\t// Clear out all tile content\n\t\t\tif ( isExternalTileset ) {\n\n\t\t\t\tt.children.length = 0;\n\t\t\t\tt.__childrenProcessed = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\t\t\tplugin.disposeTile && plugin.disposeTile( t );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// Decrement stats\n\t\t\tstats.inCache --;\n\t\t\tif ( this.cachedSinceLoadComplete.has( tile ) ) {\n\n\t\t\t\tthis.cachedSinceLoadComplete.delete( tile );\n\t\t\t\tstats.inCacheSinceLoad --;\n\n\t\t\t}\n\n\t\t\tif ( t.__loadingState === LOADING ) {\n\n\t\t\t\tstats.downloading --;\n\n\t\t\t} else if ( t.__loadingState === PARSING ) {\n\n\t\t\t\tstats.parsing --;\n\n\t\t\t}\n\n\t\t\tt.__loadingState = UNLOADED;\n\n\t\t\tparseQueue.remove( t );\n\t\t\tdownloadQueue.remove( t );\n\n\t\t} );\n\n\t\t// if we couldn't add the tile to the lru cache because it's full then skip\n\t\tif ( ! addedSuccessfully ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if this is the beginning of a new set of tiles to load and dispatch and event\n\t\tif ( ! this.isLoading ) {\n\n\t\t\tthis.isLoading = true;\n\t\t\tthis.dispatchEvent( { type: 'tiles-load-start' } );\n\n\t\t}\n\n\t\tlruCache.setMemoryUsage( tile, this.getBytesUsed( tile ) );\n\t\tthis.cachedSinceLoadComplete.add( tile );\n\t\tstats.inCacheSinceLoad ++;\n\t\tstats.inCache ++;\n\t\tstats.downloading ++;\n\t\ttile.__loadingState = LOADING;\n\n\t\t// queue the download and parse\n\t\treturn downloadQueue.add( tile, downloadTile => {\n\n\t\t\tif ( signal.aborted ) {\n\n\t\t\t\treturn Promise.resolve();\n\n\t\t\t}\n\n\t\t\tconst res = this.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( uri, { ...this.fetchOptions, signal } ) );\n\t\t\tthis.dispatchEvent( { type: 'tile-download-start', tile } );\n\t\t\treturn res;\n\n\t\t} )\n\t\t\t.then( res => {\n\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( res instanceof Response ) ) {\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} else if ( res.ok ) {\n\n\t\t\t\t\treturn extension === 'json' ? res.json() : res.arrayBuffer();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `Failed to load model with error code ${res.status}` );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( content => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tstats.downloading --;\n\t\t\t\tstats.parsing ++;\n\t\t\t\ttile.__loadingState = PARSING;\n\n\t\t\t\treturn parseQueue.add( tile, parseTile => {\n\n\t\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\t\treturn Promise.resolve();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( extension === 'json' && content.root ) {\n\n\t\t\t\t\t\tthis.preprocessTileset( content, uri, tile );\n\t\t\t\t\t\ttile.children.push( content.root );\n\t\t\t\t\t\texternalTileset = content;\n\t\t\t\t\t\tisExternalTileset = true;\n\t\t\t\t\t\treturn Promise.resolve();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn this.invokeOnePlugin( plugin => plugin.parseTile && plugin.parseTile( content, parseTile, extension, uri, signal ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( () => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tstats.parsing --;\n\t\t\t\ttile.__loadingState = LOADED;\n\t\t\t\tlruCache.setLoaded( tile, true );\n\n\t\t\t\t// If the memory of the item hasn't been registered yet then that means the memory usage hasn't\n\t\t\t\t// been accounted for by the cache yet so we need to check if it fits or if we should remove it.\n\t\t\t\tconst bytesUsed = this.getBytesUsed( tile );\n\t\t\t\tif ( lruCache.getMemoryUsage( tile ) === 0 && bytesUsed > 0 && lruCache.isFull() ) {\n\n\t\t\t\t\t// And if the cache is full due to newly loaded memory then lets discard this tile - it will\n\t\t\t\t\t// be loaded again later from the disk cache if needed.\n\t\t\t\t\tlruCache.remove( tile );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\t// update memory\n\t\t\t\tlruCache.setMemoryUsage( tile, bytesUsed );\n\n\t\t\t\t// dispatch an event indicating that this model has completed and that a new\n\t\t\t\t// call to \"update\" is needed.\n\t\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\t\t\t\tthis.dispatchEvent( { type: 'load-content' } );\n\t\t\t\tif ( isExternalTileset ) {\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-tileset',\n\t\t\t\t\t\ttileset: externalTileset,\n\t\t\t\t\t\turl: uri,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tile.cached.scene ) {\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-model',\n\t\t\t\t\t\tscene: tile.cached.scene,\n\t\t\t\t\t\ttile,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( error => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( error.name !== 'AbortError' ) {\n\n\t\t\t\t\tparseQueue.remove( tile );\n\t\t\t\t\tdownloadQueue.remove( tile );\n\n\t\t\t\t\tif ( tile.__loadingState === PARSING ) {\n\n\t\t\t\t\t\tstats.parsing --;\n\n\t\t\t\t\t} else if ( tile.__loadingState === LOADING ) {\n\n\t\t\t\t\t\tstats.downloading --;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstats.failed ++;\n\n\t\t\t\t\tconsole.error( `TilesRenderer : Failed to load tile at url \"${ tile.content.uri }\".` );\n\t\t\t\t\tconsole.error( error );\n\t\t\t\t\ttile.__loadingState = FAILED;\n\t\t\t\t\tlruCache.setLoaded( tile, true );\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-error',\n\t\t\t\t\t\ttile,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\turl: uri,\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlruCache.remove( tile );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t}\n\n}\n","import { Group, Matrix4 } from 'three';\n\n// Specialization of \"Group\" that only updates world matrices of children if\n// the transform has changed since the last update and ignores the \"force\"\n// parameter under the assumption that the children tiles will not move.\nconst tempMat = new Matrix4();\nexport class TilesGroup extends Group {\n\n\tconstructor( tilesRenderer ) {\n\n\t\tsuper();\n\t\tthis.isTilesGroup = true;\n\t\tthis.name = 'TilesRenderer.TilesGroup';\n\t\tthis.tilesRenderer = tilesRenderer;\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\t// returning \"false\" ends raycast traversal\n\t\tif ( this.tilesRenderer.optimizeRaycast ) {\n\n\t\t\tthis.tilesRenderer.raycast( raycaster, intersects );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) {\n\n\t\t\tthis.updateMatrix();\n\n\t\t}\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\ttempMat.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\ttempMat.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t// check if the matrix changed relative to what it was.\n\t\t\tconst elA = tempMat.elements;\n\t\t\tconst elB = this.matrixWorld.elements;\n\t\t\tlet isDifferent = false;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\tconst itemA = elA[ i ];\n\t\t\t\tconst itemB = elB[ i ];\n\t\t\t\tconst diff = Math.abs( itemA - itemB );\n\n\t\t\t\tif ( diff > Number.EPSILON ) {\n\n\t\t\t\t\tisDifferent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isDifferent ) {\n\n\t\t\t\tthis.matrixWorld.copy( tempMat );\n\t\t\t\tthis.matrixWorldInverse.copy( tempMat ).invert();\n\n\t\t\t\t// update children\n\t\t\t\t// the children will not have to change unless the parent group has updated\n\t\t\t\tconst children = this.children;\n\t\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\tchildren[ i ].updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tif ( this.parent && updateParents ) {\n\n\t\t\tthis.parent.updateWorldMatrix( updateParents, false );\n\n\t\t}\n\n\t\t// run the normal update function to ensure children and inverse matrices are in sync\n\t\tthis.updateMatrixWorld( true );\n\n\t}\n\n}\n","import { Ray, Vector3 } from 'three';\n\n// In three.js r165 and higher raycast traversal can be ended early\nconst _localRay = new Ray();\nconst _vec = new Vector3();\nconst _hitArray = [];\n\nfunction distanceSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectTileScene( tile, raycaster, renderer, intersects ) {\n\n\tconst { scene } = tile.cached;\n\tconst didRaycast = renderer.invokeOnePlugin( plugin => plugin.raycastTile && plugin.raycastTile( tile, scene, raycaster, intersects ) );\n\tif ( ! didRaycast ) {\n\n\t\traycaster.intersectObject( scene, true, intersects );\n\n\t}\n\n}\n\nfunction intersectTileSceneFirstHist( tile, raycaster, renderer ) {\n\n\tintersectTileScene( tile, raycaster, renderer, _hitArray );\n\t_hitArray.sort( distanceSort );\n\n\tconst hit = _hitArray[ 0 ] || null;\n\t_hitArray.length = 0;\n\treturn hit;\n\n}\n\nfunction isTileInitialized( tile ) {\n\n\treturn '__used' in tile;\n\n}\n\n// Returns the closest hit when traversing the tree\nexport function raycastTraverseFirstHit( renderer, tile, raycaster, localRay = null ) {\n\n\tconst { group, activeTiles } = renderer;\n\n\t// get the ray in the local group frame\n\tif ( localRay === null ) {\n\n\t\tlocalRay = _localRay;\n\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( group.matrixWorldInverse );\n\n\t}\n\n\t// get a set of intersections so we intersect the nearest one first\n\tconst array = [];\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst child = children[ i ];\n\t\tif ( ! isTileInitialized( child ) || ! child.__used ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// track the tile and hit distance for sorting\n\t\tconst boundingVolume = child.cached.boundingVolume;\n\t\tif ( boundingVolume.intersectRay( localRay, _vec ) !== null ) {\n\n\t\t\t_vec.applyMatrix4( group.matrixWorld );\n\t\t\tarray.push( {\n\t\t\t\tdistance: _vec.distanceToSquared( raycaster.ray.origin ),\n\t\t\t\ttile: child,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// sort them by ascending distance\n\tarray.sort( distanceSort );\n\n\t// If the root is active make sure we've checked it\n\tlet bestHit = null;\n\tlet bestHitDistSq = Infinity;\n\tif ( activeTiles.has( tile ) ) {\n\n\t\tconst hit = intersectTileSceneFirstHist( tile, raycaster, renderer );\n\t\tif ( hit ) {\n\n\t\t\tbestHit = hit;\n\t\t\tbestHitDistSq = hit.distance * hit.distance;\n\n\t\t}\n\n\t}\n\n\t// traverse until we find the best hit and early out if a tile bounds\n\t// couldn't possible include a best hit\n\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\tconst data = array[ i ];\n\t\tconst boundingVolumeDistSq = data.distance;\n\t\tconst tile = data.tile;\n\t\tif ( boundingVolumeDistSq > bestHitDistSq ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\tconst hit = raycastTraverseFirstHit( renderer, tile, raycaster, localRay );\n\t\tif ( hit ) {\n\n\t\t\tconst hitDistSq = hit.distance * hit.distance;\n\t\t\tif ( hitDistSq < bestHitDistSq ) {\n\n\t\t\t\tbestHit = hit;\n\t\t\t\tbestHitDistSq = hitDistSq;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn bestHit;\n\n}\n\nexport function raycastTraverse( renderer, tile, raycaster, intersects, localRay = null ) {\n\n\t// if the tile has not been asynchronously initialized then there's no point in\n\t// traversing the tiles to check intersections.\n\tif ( ! isTileInitialized( tile ) ) {\n\n\t\treturn;\n\n\t}\n\n\tconst { group, activeTiles } = renderer;\n\tconst { boundingVolume } = tile.cached;\n\n\t// get the ray in the local group frame\n\tif ( localRay === null ) {\n\n\t\tlocalRay = _localRay;\n\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( group.matrixWorldInverse );\n\n\t}\n\n\t// exit early if the tile isn't used or the bounding volume is not intersected\n\tif ( ! tile.__used || ! boundingVolume.intersectsRay( localRay ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// only intersect the tile geometry if it's active\n\tif ( activeTiles.has( tile ) ) {\n\n\t\tintersectTileScene( tile, raycaster, renderer, intersects );\n\n\t}\n\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\traycastTraverse( renderer, children[ i ], raycaster, intersects, localRay );\n\n\t}\n\n}\n","import { Matrix4, Box3, Vector3, Plane, Ray } from 'three';\n\nconst _worldMin = new Vector3();\nconst _worldMax = new Vector3();\nconst _norm = new Vector3();\nconst _ray = new Ray();\n\nexport class OBB {\n\n\tconstructor( box = new Box3(), transform = new Matrix4() ) {\n\n\t\tthis.box = box.clone();\n\t\tthis.transform = transform.clone();\n\t\tthis.inverseTransform = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.planes = new Array( 6 ).fill().map( () => new Plane() );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.box.copy( source.box );\n\t\tthis.transform.copy( source.transform );\n\t\tthis.update();\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Clamps the given point within the bounds of this OBB\n\t * @param {Vector3} point\n\t * @param {Vector3} result\n\t * @returns {Vector3}\n\t */\n\tclampPoint( point, result ) {\n\n\t\treturn result.copy( point )\n\t\t\t.applyMatrix4( this.inverseTransform )\n\t\t\t.clamp( this.box.min, this.box.max )\n\t\t\t.applyMatrix4( this.transform );\n\n\t}\n\n\t/**\n\t * Returns the distance from any edge of this OBB to the specified point.\n\t * If the point lies inside of this box, the distance will be 0.\n\t * @param {Vector3} point\n\t * @returns {number}\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _norm ).distanceTo( point );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\t_norm.copy( point ).applyMatrix4( this.inverseTransform );\n\t\treturn this.box.containsPoint( _norm );\n\n\t}\n\n\t// returns boolean indicating whether the ray has intersected the obb\n\tintersectsRay( ray ) {\n\n\t\t_ray.copy( ray ).applyMatrix4( this.inverseTransform );\n\t\treturn _ray.intersectsBox( this.box );\n\n\t}\n\n\t// Sets \"target\" equal to the intersection point.\n\t// Returns \"null\" if no intersection found.\n\tintersectRay( ray, target ) {\n\n\t\t_ray.copy( ray ).applyMatrix4( this.inverseTransform );\n\t\tif ( _ray.intersectBox( this.box, target ) ) {\n\n\t\t\ttarget.applyMatrix4( this.transform );\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst { points, inverseTransform, transform, box } = this;\n\t\tinverseTransform.copy( transform ).invert();\n\n\t\tconst { min, max } = box;\n\t\tlet index = 0;\n\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\tpoints[ index ].set(\n\t\t\t\t\t\tx < 0 ? min.x : max.x,\n\t\t\t\t\t\ty < 0 ? min.y : max.y,\n\t\t\t\t\t\tz < 0 ? min.z : max.z,\n\t\t\t\t\t).applyMatrix4( transform );\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.updatePlanes();\n\n\t}\n\n\tupdatePlanes() {\n\n\t\t_worldMin.copy( this.box.min ).applyMatrix4( this.transform );\n\t\t_worldMax.copy( this.box.max ).applyMatrix4( this.transform );\n\n\t\t_norm.set( 0, 0, 1 ).transformDirection( this.transform );\n\t\tthis.planes[ 0 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 1 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t\t_norm.set( 0, 1, 0 ).transformDirection( this.transform );\n\t\tthis.planes[ 2 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 3 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t\t_norm.set( 1, 0, 0 ).transformDirection( this.transform );\n\t\tthis.planes[ 4 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 5 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tthis.clampPoint( sphere.center, _norm );\n\t\treturn _norm.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsFrustum( frustum ) {\n\n\t\treturn this._intersectsPlaneShape( frustum.planes, frustum.points );\n\n\t}\n\n\tintersectsOBB( obb ) {\n\n\t\treturn this._intersectsPlaneShape( obb.planes, obb.points );\n\n\t}\n\n\t// takes a series of 6 planes that define and enclosed shape and the 8 points that lie at the corners\n\t// of that shape to determine whether the OBB is intersected with.\n\t_intersectsPlaneShape( otherPlanes, otherPoints ) {\n\n\t\tconst thisPoints = this.points;\n\t\tconst thisPlanes = this.planes;\n\n\t\t// based on three.js' Box3 \"intersects frustum\" function\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = otherPlanes[ i ];\n\t\t\tlet maxDistance = - Infinity;\n\t\t\tfor ( let j = 0; j < 8; j ++ ) {\n\n\t\t\t\tconst v = thisPoints[ j ];\n\t\t\t\tconst dist = plane.distanceToPoint( v );\n\t\t\t\tmaxDistance = maxDistance < dist ? dist : maxDistance;\n\n\t\t\t}\n\n\t\t\tif ( maxDistance < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// do the opposite check using the obb planes to avoid false positives\n\t\t// this check is not performed by three.js' AABB logic but helps prevent a lot incorrect intersection reports\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = thisPlanes[ i ];\n\t\t\tlet maxDistance = - Infinity;\n\t\t\tfor ( let j = 0; j < 8; j ++ ) {\n\n\t\t\t\tconst v = otherPoints[ j ];\n\t\t\t\tconst dist = plane.distanceToPoint( v );\n\t\t\t\tmaxDistance = maxDistance < dist ? dist : maxDistance;\n\n\t\t\t}\n\n\t\t\tif ( maxDistance < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n}\n","import { Vector3, Sphere } from 'three';\nimport { OBB } from './OBB.js';\nimport { EllipsoidRegion } from './EllipsoidRegion.js';\n\nconst _vecX = new Vector3();\nconst _vecY = new Vector3();\nconst _vecZ = new Vector3();\nconst _sphereVec = new Vector3();\nconst _obbVec = new Vector3();\n\n// TODO: check region more precisely in all functions\nexport class TileBoundingVolume {\n\n\tconstructor() {\n\n\t\tthis.sphere = null;\n\t\tthis.obb = null;\n\t\tthis.region = null;\n\n\t\tthis.regionObb = null;\n\n\t}\n\n\tintersectsRay( ray ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\t// Early out if we don't hit this tile sphere\n\t\tif ( sphere && ! ray.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// Early out if we don't this this tile box\n\t\tif ( obb && ! obb.intersectsRay( ray ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectRay( ray, target = null ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\tlet sphereDistSq = - Infinity;\n\t\tlet obbDistSq = - Infinity;\n\n\t\tif ( sphere ) {\n\n\t\t\tif ( ray.intersectSphere( sphere, _sphereVec ) ) {\n\n\t\t\t\tsphereDistSq = sphere.containsPoint( ray.origin ) ? 0 : ray.origin.distanceToSquared( _sphereVec );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( obb ) {\n\n\t\t\tif ( obb.intersectRay( ray, _obbVec ) ) {\n\n\t\t\t\tobbDistSq = obb.containsPoint( ray.origin ) ? 0 : ray.origin.distanceToSquared( _obbVec );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if we didn't hit anything then exit\n\t\tconst furthestDist = Math.max( sphereDistSq, obbDistSq );\n\t\tif ( furthestDist === - Infinity ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// get the furthest hit point if needed\n\t\tray.at( Math.sqrt( furthestDist ), target );\n\t\treturn target;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\tlet sphereDistance = - Infinity;\n\t\tlet obbDistance = - Infinity;\n\n\t\tif ( sphere ) {\n\n\t\t\t// Sphere#distanceToPoint is negative inside the sphere, whereas Box3#distanceToPoint is\n\t\t\t// zero inside the box. Clipping the distance to a minimum of zero ensures that both\n\t\t\t// types of bounding volume behave the same way.\n\t\t\tsphereDistance = Math.max( sphere.distanceToPoint( point ), 0 );\n\n\t\t}\n\n\t\tif ( obb ) {\n\n\t\t\tobbDistance = obb.distanceToPoint( point );\n\n\t\t}\n\n\t\t// return the further distance of the two volumes\n\t\treturn sphereDistance > obbDistance ? sphereDistance : obbDistance;\n\n\t}\n\n\tintersectsFrustum( frustum ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! frustum.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsFrustum( frustum ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// if we don't have a sphere or obb then just say we did intersect\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tintersectsSphere( otherSphere ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! sphere.intersectsSphere( otherSphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsSphere( otherSphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tintersectsOBB( otherObb ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! otherObb.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsOBB( otherObb ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tgetOBB( targetBox, targetMatrix ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tif ( obb ) {\n\n\t\t\ttargetBox.copy( obb.box );\n\t\t\ttargetMatrix.copy( obb.transform );\n\n\t\t} else {\n\n\t\t\tthis.getAABB( targetBox );\n\t\t\ttargetMatrix.identity();\n\n\t\t}\n\n\t}\n\n\tgetAABB( target ) {\n\n\t\tif ( this.sphere ) {\n\n\t\t\tthis.sphere.getBoundingBox( target );\n\n\t\t} else {\n\n\t\t\tconst obb = this.obb || this.regionObb;\n\t\t\ttarget.copy( obb.box ).applyMatrix4( obb.transform );\n\n\t\t}\n\n\t}\n\n\tgetSphere( target ) {\n\n\t\tif ( this.sphere ) {\n\n\t\t\ttarget.copy( this.sphere );\n\n\t\t} else if ( this.region ) {\n\n\t\t\tthis.region.getBoundingSphere( target );\n\n\t\t} else {\n\n\t\t\tconst obb = this.obb || this.regionObb;\n\t\t\tobb.box.getBoundingSphere( target );\n\t\t\ttarget.applyMatrix4( obb.transform );\n\n\t\t}\n\n\t}\n\n\tsetObbData( data, transform ) {\n\n\t\tconst obb = new OBB();\n\n\t\t// get the extents of the bounds in each axis\n\t\t_vecX.set( data[ 3 ], data[ 4 ], data[ 5 ] );\n\t\t_vecY.set( data[ 6 ], data[ 7 ], data[ 8 ] );\n\t\t_vecZ.set( data[ 9 ], data[ 10 ], data[ 11 ] );\n\n\t\tconst scaleX = _vecX.length();\n\t\tconst scaleY = _vecY.length();\n\t\tconst scaleZ = _vecZ.length();\n\n\t\t_vecX.normalize();\n\t\t_vecY.normalize();\n\t\t_vecZ.normalize();\n\n\t\t// handle the case where the box has a dimension of 0 in one axis\n\t\tif ( scaleX === 0 ) {\n\n\t\t\t_vecX.crossVectors( _vecY, _vecZ );\n\n\t\t}\n\n\t\tif ( scaleY === 0 ) {\n\n\t\t\t_vecY.crossVectors( _vecX, _vecZ );\n\n\t\t}\n\n\t\tif ( scaleZ === 0 ) {\n\n\t\t\t_vecZ.crossVectors( _vecX, _vecY );\n\n\t\t}\n\n\t\t// create the oriented frame that the box exists in\n\t\tobb.transform\n\t\t\t.set(\n\t\t\t\t_vecX.x, _vecY.x, _vecZ.x, data[ 0 ],\n\t\t\t\t_vecX.y, _vecY.y, _vecZ.y, data[ 1 ],\n\t\t\t\t_vecX.z, _vecY.z, _vecZ.z, data[ 2 ],\n\t\t\t\t0, 0, 0, 1\n\t\t\t)\n\t\t\t.premultiply( transform );\n\n\t\t// scale the box by the extents\n\t\tobb.box.min.set( - scaleX, - scaleY, - scaleZ );\n\t\tobb.box.max.set( scaleX, scaleY, scaleZ );\n\t\tobb.update();\n\t\tthis.obb = obb;\n\n\t}\n\n\tsetSphereData( x, y, z, radius, transform ) {\n\n\t\tconst sphere = new Sphere();\n\t\tsphere.center.set( x, y, z );\n\t\tsphere.radius = radius;\n\t\tsphere.applyMatrix4( transform );\n\t\tthis.sphere = sphere;\n\n\t}\n\n\tsetRegionData( ellipsoid, west, south, east, north, minHeight, maxHeight ) {\n\n\t\tconst region = new EllipsoidRegion(\n\t\t\t...ellipsoid.radius,\n\t\t\tsouth, north,\n\t\t\twest, east,\n\t\t\tminHeight, maxHeight,\n\t\t);\n\n\t\tconst obb = new OBB();\n\t\tregion.getBoundingBox( obb.box, obb.transform );\n\t\tobb.update();\n\n\t\tthis.region = region;\n\t\tthis.regionObb = obb;\n\n\t}\n\n}\n","import { Frustum, Matrix3, Vector3 } from 'three';\n\nconst _mat3 = new Matrix3();\n\n// Solve a system of equations to find the point where the three planes intersect\nfunction findIntersectionPoint( plane1, plane2, plane3, target ) {\n\n\t// Create the matrix A using the normals of the planes as rows\n\tconst A = _mat3.set(\n\t\tplane1.normal.x, plane1.normal.y, plane1.normal.z,\n\t\tplane2.normal.x, plane2.normal.y, plane2.normal.z,\n\t\tplane3.normal.x, plane3.normal.y, plane3.normal.z\n\t);\n\n\t// Create the vector B using the constants of the planes\n\ttarget.set( - plane1.constant, - plane2.constant, - plane3.constant );\n\n\t// Solve for X by applying the inverse matrix to B\n\ttarget.applyMatrix3( A.invert() );\n\n\treturn target;\n\n}\n\nclass ExtendedFrustum extends Frustum {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.points = Array( 8 ).fill().map( () => new Vector3() );\n\n\t}\n\n\tsetFromProjectionMatrix( m, coordinateSystem ) {\n\n\t\tsuper.setFromProjectionMatrix( m, coordinateSystem );\n\t\tthis.calculateFrustumPoints();\n\t\treturn this;\n\n\t}\n\n\tcalculateFrustumPoints() {\n\n\t\tconst { planes, points } = this;\n\t\tconst planeIntersections = [\n\t\t\t[ planes[ 0 ], planes[ 3 ], planes[ 4 ] ], // Near top left\n\t\t\t[ planes[ 1 ], planes[ 3 ], planes[ 4 ] ], // Near top right\n\t\t\t[ planes[ 0 ], planes[ 2 ], planes[ 4 ] ], // Near bottom left\n\t\t\t[ planes[ 1 ], planes[ 2 ], planes[ 4 ] ], // Near bottom right\n\t\t\t[ planes[ 0 ], planes[ 3 ], planes[ 5 ] ], // Far top left\n\t\t\t[ planes[ 1 ], planes[ 3 ], planes[ 5 ] ], // Far top right\n\t\t\t[ planes[ 0 ], planes[ 2 ], planes[ 5 ] ], // Far bottom left\n\t\t\t[ planes[ 1 ], planes[ 2 ], planes[ 5 ] ], // Far bottom right\n\t\t];\n\n\t\tplaneIntersections.forEach( ( planes, index ) => {\n\n\t\t\tfindIntersectionPoint( planes[ 0 ], planes[ 1 ], planes[ 2 ], points[ index ] );\n\n\t\t} );\n\n\t}\n\n}\n\nexport { ExtendedFrustum };\n","import { estimateBytesUsed as _estimateBytesUsed } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport { TextureUtils } from 'three';\n\nexport function getTextureByteLength( tex ) {\n\n\tif ( ! tex ) {\n\n\t\treturn 0;\n\n\t}\n\n\tconst { format, type, image } = tex;\n\tconst { width, height } = image;\n\n\tlet bytes = TextureUtils.getByteLength( width, height, format, type );\n\tbytes *= tex.generateMipmaps ? 4 / 3 : 1;\n\n\treturn bytes;\n\n}\n\n// Returns the estimated number of bytes used by the object\nexport function estimateBytesUsed( object ) {\n\n\tconst dedupeSet = new Set();\n\n\tlet totalBytes = 0;\n\tobject.traverse( c => {\n\n\t\t// get geometry bytes\n\t\tif ( c.geometry && ! dedupeSet.has( c.geometry ) ) {\n\n\t\t\ttotalBytes += _estimateBytesUsed( c.geometry );\n\t\t\tdedupeSet.add( c.geometry );\n\n\t\t}\n\n\t\t// get material bytes\n\t\tif ( c.material ) {\n\n\t\t\tconst material = c.material;\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tconst value = material[ key ];\n\t\t\t\tif ( value && value.isTexture && ! dedupeSet.has( value ) ) {\n\n\t\t\t\t\ttotalBytes += getTextureByteLength( value );\n\t\t\t\t\tdedupeSet.add( value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn totalBytes;\n\n}\n","import { TilesRendererBase, LoaderUtils } from '3d-tiles-renderer/core';\nimport { B3DMLoader } from '../loaders/B3DMLoader.js';\nimport { PNTSLoader } from '../loaders/PNTSLoader.js';\nimport { I3DMLoader } from '../loaders/I3DMLoader.js';\nimport { CMPTLoader } from '../loaders/CMPTLoader.js';\nimport { TilesGroup } from './TilesGroup.js';\nimport {\n\tMatrix4,\n\tVector3,\n\tVector2,\n\tEuler,\n\tLoadingManager,\n\tEventDispatcher,\n\tGroup,\n} from 'three';\nimport { raycastTraverse, raycastTraverseFirstHit } from './raycastTraverse.js';\nimport { TileBoundingVolume } from '../math/TileBoundingVolume.js';\nimport { ExtendedFrustum } from '../math/ExtendedFrustum.js';\nimport { estimateBytesUsed } from '../utils/MemoryUtils.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nconst _mat = new Matrix4();\nconst _euler = new Euler();\n\n// In three.js r165 and higher raycast traversal can be ended early\nconst INITIAL_FRUSTUM_CULLED = Symbol( 'INITIAL_FRUSTUM_CULLED' );\nconst tempMat = new Matrix4();\nconst tempVector = new Vector3();\nconst tempVector2 = new Vector2();\nconst viewErrorTarget = {\n\tinView: false,\n\terror: Infinity,\n};\n\nconst X_AXIS = new Vector3( 1, 0, 0 );\nconst Y_AXIS = new Vector3( 0, 1, 0 );\n\nfunction updateFrustumCulled( object, toInitialValue ) {\n\n\tobject.traverse( c => {\n\n\t\tc.frustumCulled = c[ INITIAL_FRUSTUM_CULLED ] && toInitialValue;\n\n\t} );\n\n}\n\nexport class TilesRenderer extends TilesRendererBase {\n\n\tget autoDisableRendererCulling() {\n\n\t\treturn this._autoDisableRendererCulling;\n\n\t}\n\n\tset autoDisableRendererCulling( value ) {\n\n\t\tif ( this._autoDisableRendererCulling !== value ) {\n\n\t\t\tsuper._autoDisableRendererCulling = value;\n\t\t\tthis.forEachLoadedModel( ( scene ) => {\n\n\t\t\t\tupdateFrustumCulled( scene, ! value );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tget optimizeRaycast() {\n\n\t\treturn this._optimizeRaycast;\n\n\t}\n\n\tset optimizeRaycast( v ) {\n\n\t\tconsole.warn( 'TilesRenderer: The \"optimizeRaycast\" option has been deprecated.' );\n\t\tthis._optimizeRaycast = v;\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.group = new TilesGroup( this );\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\t\tthis.cameras = [];\n\t\tthis.cameraMap = new Map();\n\t\tthis.cameraInfo = [];\n\t\tthis._optimizeRaycast = true;\n\t\tthis._upRotationMatrix = new Matrix4();\n\t\tthis._bytesUsed = new WeakMap();\n\n\t\t// flag indicating whether frustum culling should be disabled\n\t\tthis._autoDisableRendererCulling = true;\n\n\t\tthis.manager = new LoadingManager();\n\n\t\t// saved for event dispatcher functions\n\t\tthis._listeners = {};\n\n\t}\n\n\taddEventListener( type, listener ) {\n\n\t\tif ( type === 'load-tile-set' ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: \"load-tile-set\" event has been deprecated. Use \"load-tileset\" instead.' );\n\t\t\ttype = 'load-tileset';\n\n\t\t}\n\n\t\tEventDispatcher.prototype.addEventListener.call( this, type, listener );\n\n\t}\n\n\thasEventListener( type, listener ) {\n\n\t\tif ( type === 'load-tile-set' ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: \"load-tile-set\" event has been deprecated. Use \"load-tileset\" instead.' );\n\t\t\ttype = 'load-tileset';\n\n\t\t}\n\n\t\treturn EventDispatcher.prototype.hasEventListener.call( this, type, listener );\n\n\t}\n\n\tremoveEventListener( type, listener ) {\n\n\t\tif ( type === 'load-tile-set' ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: \"load-tile-set\" event has been deprecated. Use \"load-tileset\" instead.' );\n\t\t\ttype = 'load-tileset';\n\n\t\t}\n\n\t\tEventDispatcher.prototype.removeEventListener.call( this, type, listener );\n\n\t}\n\n\tdispatchEvent( e ) {\n\n\t\tif ( 'tileset' in e ) {\n\n\t\t\tObject.defineProperty( e, 'tileSet', {\n\t\t\t\tget() {\n\n\t\t\t\t\tconsole.warn( 'TilesRenderer: \"event.tileSet\" has been deprecated. Use \"event.tileset\" instead.' );\n\t\t\t\t\treturn e.tileset;\n\n\t\t\t\t},\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t} );\n\n\t\t}\n\n\t\tEventDispatcher.prototype.dispatchEvent.call( this, e );\n\n\t}\n\n\t/* Public API */\n\tgetBoundingBox( target ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.cached.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getAABB( target );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetOrientedBoundingBox( targetBox, targetMatrix ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.cached.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getOBB( targetBox, targetMatrix );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.cached.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getSphere( target );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tforEachLoadedModel( callback ) {\n\n\t\tthis.traverse( tile => {\n\n\t\t\tconst scene = tile.cached && tile.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tcallback( scene, tile );\n\n\t\t\t}\n\n\t\t}, null, false );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( raycaster.firstHitOnly ) {\n\n\t\t\tconst hit = raycastTraverseFirstHit( this, this.root, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\traycastTraverse( this, this.root, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\thasCamera( camera ) {\n\n\t\treturn this.cameraMap.has( camera );\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\tcameraMap.set( camera, new Vector2() );\n\t\t\tcameras.push( camera );\n\t\t\tthis.dispatchEvent( { type: 'add-camera', camera } );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tsetResolution( camera, xOrVec, y ) {\n\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst width = xOrVec.isVector2 ? xOrVec.x : xOrVec;\n\t\tconst height = xOrVec.isVector2 ? xOrVec.y : y;\n\t\tconst cameraVec = cameraMap.get( camera );\n\n\t\tif ( cameraVec.width !== width || cameraVec.height !== height ) {\n\n\t\t\tcameraVec.set( width, height );\n\t\t\tthis.dispatchEvent( { type: 'camera-resolution-change' } );\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tsetResolutionFromRenderer( camera, renderer ) {\n\n\t\trenderer.getSize( tempVector2 );\n\n\t\treturn this.setResolution( camera, tempVector2.x, tempVector2.y );\n\n\t}\n\n\tdeleteCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( cameraMap.has( camera ) ) {\n\n\t\t\tconst index = cameras.indexOf( camera );\n\t\t\tcameras.splice( index, 1 );\n\t\t\tcameraMap.delete( camera );\n\t\t\tthis.dispatchEvent( { type: 'delete-camera', camera } );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/* Overriden */\n\tloadRootTileset( ...args ) {\n\n\t\treturn super.loadRootTileset( ...args )\n\t\t\t.then( root => {\n\n\t\t\t\t// cache the gltf tileset rotation matrix\n\t\t\t\tconst { asset, extensions = {} } = root;\n\t\t\t\tconst upAxis = asset && asset.gltfUpAxis || 'y';\n\t\t\t\tswitch ( upAxis.toLowerCase() ) {\n\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tthis._upRotationMatrix.makeRotationAxis( Y_AXIS, - Math.PI / 2 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'y':\n\t\t\t\t\t\tthis._upRotationMatrix.makeRotationAxis( X_AXIS, Math.PI / 2 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// update the ellipsoid based on the extension\n\t\t\t\tif ( '3DTILES_ellipsoid' in extensions ) {\n\n\t\t\t\t\tconst ext = extensions[ '3DTILES_ellipsoid' ];\n\t\t\t\t\tconst { ellipsoid } = this;\n\t\t\t\t\tellipsoid.name = ext.body;\n\t\t\t\t\tif ( ext.radii ) {\n\n\t\t\t\t\t\tellipsoid.radius.set( ...ext.radii );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tellipsoid.radius.set( 1, 1, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn root;\n\n\t\t\t} );\n\n\t}\n\n\tupdate() {\n\n\t\t// check if the plugins that can block the tile updates require it\n\t\tlet needsUpdate = null;\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin.doTilesNeedUpdate ) {\n\n\t\t\t\tconst res = plugin.doTilesNeedUpdate();\n\t\t\t\tif ( needsUpdate === null ) {\n\n\t\t\t\t\tneedsUpdate = res;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tneedsUpdate = Boolean( needsUpdate || res );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( needsUpdate === false ) {\n\n\t\t\tthis.dispatchEvent( { type: 'update-before' } );\n\t\t\tthis.dispatchEvent( { type: 'update-after' } );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// follow through with the update\n\t\tthis.dispatchEvent( { type: 'update-before' } );\n\n\t\tconst group = this.group;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tconst cameraInfo = this.cameraInfo;\n\n\t\t// automatically scale the array of cameraInfo to match the cameras\n\t\twhile ( cameraInfo.length > cameras.length ) {\n\n\t\t\tcameraInfo.pop();\n\n\t\t}\n\n\t\twhile ( cameraInfo.length < cameras.length ) {\n\n\t\t\tcameraInfo.push( {\n\n\t\t\t\tfrustum: new ExtendedFrustum(),\n\t\t\t\tisOrthographic: false,\n\t\t\t\tsseDenominator: - 1, // used if isOrthographic:false\n\t\t\t\tposition: new Vector3(),\n\t\t\t\tinvScale: - 1,\n\t\t\t\tpixelSize: 0, // used if isOrthographic:true\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// extract scale of group container\n\t\ttempVector.setFromMatrixScale( group.matrixWorldInverse );\n\t\tif ( Math.abs( Math.max( tempVector.x - tempVector.y, tempVector.x - tempVector.z ) ) > 1e-6 ) {\n\n\t\t\tconsole.warn( 'ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.' );\n\n\t\t}\n\n\t\t// store the camera cameraInfo in the 3d tiles root frame\n\t\tfor ( let i = 0, l = cameraInfo.length; i < l; i ++ ) {\n\n\t\t\tconst camera = cameras[ i ];\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tconst frustum = info.frustum;\n\t\t\tconst position = info.position;\n\t\t\tconst resolution = cameraMap.get( camera );\n\n\t\t\tif ( resolution.width === 0 || resolution.height === 0 ) {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: resolution for camera error calculation is not set.' );\n\n\t\t\t}\n\n\t\t\t// Read the calculated projection matrix directly to support custom Camera implementations\n\t\t\tconst projection = camera.projectionMatrix.elements;\n\n\t\t\t// The last element of the projection matrix is 1 for orthographic, 0 for perspective\n\t\t\tinfo.isOrthographic = projection[ 15 ] === 1;\n\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\t// See OrthographicCamera.updateProjectionMatrix and Matrix4.makeOrthographic:\n\t\t\t\t// the view width and height are used to populate matrix elements 0 and 5.\n\t\t\t\tconst w = 2 / projection[ 0 ];\n\t\t\t\tconst h = 2 / projection[ 5 ];\n\t\t\t\tinfo.pixelSize = Math.max( h / resolution.height, w / resolution.width );\n\n\t\t\t} else {\n\n\t\t\t\t// See PerspectiveCamera.updateProjectionMatrix and Matrix4.makePerspective:\n\t\t\t\t// the vertical FOV is used to populate matrix element 5.\n\t\t\t\tinfo.sseDenominator = ( 2 / projection[ 5 ] ) / resolution.height;\n\n\t\t\t}\n\n\t\t\t// get frustum in group root frame\n\t\t\ttempMat.copy( group.matrixWorld );\n\t\t\ttempMat.premultiply( camera.matrixWorldInverse );\n\t\t\ttempMat.premultiply( camera.projectionMatrix );\n\n\t\t\tfrustum.setFromProjectionMatrix( tempMat );\n\n\t\t\t// get transform position in group root frame\n\t\t\tposition.set( 0, 0, 0 );\n\t\t\tposition.applyMatrix4( camera.matrixWorld );\n\t\t\tposition.applyMatrix4( group.matrixWorldInverse );\n\n\t\t}\n\n\t\tsuper.update();\n\n\t\tthis.dispatchEvent( { type: 'update-after' } );\n\n\t\t// check for cameras _after_ base update so we can enable pre-loading the root tileset\n\t\tif ( cameras.length === 0 && this.root ) {\n\n\t\t\tlet found = false;\n\t\t\tthis.invokeAllPlugins( plugin => found = found || Boolean( plugin !== this && plugin.calculateTileViewError ) );\n\t\t\tif ( found === false ) {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: no cameras defined. Cannot update 3d tiles.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tpreprocessNode( tile, tilesetDir, parentTile = null ) {\n\n\t\tsuper.preprocessNode( tile, tilesetDir, parentTile );\n\n\t\tconst transform = new Matrix4();\n\t\tif ( tile.transform ) {\n\n\t\t\tconst transformArr = tile.transform;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransform.elements[ i ] = transformArr[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parentTile ) {\n\n\t\t\ttransform.premultiply( parentTile.cached.transform );\n\n\t\t}\n\n\t\tconst transformInverse = new Matrix4().copy( transform ).invert();\n\t\tconst boundingVolume = new TileBoundingVolume();\n\t\tif ( 'sphere' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setSphereData( ...tile.boundingVolume.sphere, transform );\n\n\t\t}\n\n\t\tif ( 'box' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setObbData( tile.boundingVolume.box, transform );\n\n\t\t}\n\n\t\tif ( 'region' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setRegionData( this.ellipsoid, ...tile.boundingVolume.region );\n\n\t\t}\n\n\t\ttile.cached = {\n\n\t\t\ttransform,\n\t\t\ttransformInverse,\n\n\t\t\tactive: false,\n\n\t\t\tboundingVolume,\n\n\t\t\tmetadata: null,\n\t\t\tscene: null,\n\t\t\tgeometry: null,\n\t\t\tmaterials: null,\n\t\t\ttextures: null,\n\n\t\t};\n\n\t}\n\n\tasync parseTile( buffer, tile, extension, uri, abortSignal ) {\n\n\t\tconst cached = tile.cached;\n\t\tconst workingPath = LoaderUtils.getWorkingPath( uri );\n\t\tconst fetchOptions = this.fetchOptions;\n\n\t\tconst manager = this.manager;\n\t\tlet promise = null;\n\n\t\tconst cachedTransform = cached.transform;\n\t\tconst upRotationMatrix = this._upRotationMatrix;\n\t\tconst fileType = ( LoaderUtils.readMagicBytes( buffer ) || extension ).toLowerCase();\n\t\tswitch ( fileType ) {\n\n\t\t\tcase 'b3dm': {\n\n\t\t\t\tconst loader = new B3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'pnts': {\n\n\t\t\t\tconst loader = new PNTSLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'i3dm': {\n\n\t\t\t\tconst loader = new I3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\t\t\t\tloader.ellipsoid.copy( this.ellipsoid );\n\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'cmpt': {\n\n\t\t\t\tconst loader = new CMPTLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\t\t\t\tloader.ellipsoid.copy( this.ellipsoid );\n\n\t\t\t\tpromise = loader\n\t\t\t\t\t.parse( buffer )\n\t\t\t\t\t.then( res => res.scene\t);\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// 3DTILES_content_gltf\n\t\t\tcase 'gltf':\n\t\t\tcase 'glb': {\n\n\t\t\t\tconst loader = manager.getHandler( 'path.gltf' ) || manager.getHandler( 'path.glb' ) || new GLTFLoader( manager );\n\t\t\t\tloader.setWithCredentials( fetchOptions.credentials === 'include' );\n\t\t\t\tloader.setRequestHeader( fetchOptions.headers || {} );\n\t\t\t\tif ( fetchOptions.credentials === 'include' && fetchOptions.mode === 'cors' ) {\n\n\t\t\t\t\tloader.setCrossOrigin( 'use-credentials' );\n\n\t\t\t\t}\n\n\t\t\t\t// assume any pre-registered loader has paths configured as the user desires, but if we're making\n\t\t\t\t// a new loader, use the working path during parse to support relative uris on other hosts\n\t\t\t\tlet resourcePath = loader.resourcePath || loader.path || workingPath;\n\t\t\t\tif ( ! /[\\\\/]$/.test( resourcePath ) && resourcePath.length ) {\n\n\t\t\t\t\tresourcePath += '/';\n\n\t\t\t\t}\n\n\t\t\t\tpromise = loader.parseAsync( buffer, resourcePath ).then( result => {\n\n\t\t\t\t\t// glTF files are not guaranteed to include a scene object\n\t\t\t\t\tresult.scene = result.scene || new Group();\n\n\t\t\t\t\t// apply the local up-axis correction rotation\n\t\t\t\t\t// GLTFLoader seems to never set a transformation on the root scene object so\n\t\t\t\t\t// any transformations applied to it can be assumed to be applied after load\n\t\t\t\t\t// (such as applying RTC_CENTER) meaning they should happen _after_ the z-up\n\t\t\t\t\t// rotation fix which is why \"multiply\" happens here.\n\t\t\t\t\tconst { scene } = result;\n\t\t\t\t\tscene.updateMatrix();\n\t\t\t\t\tscene.matrix\n\t\t\t\t\t\t.multiply( upRotationMatrix )\n\t\t\t\t\t\t.decompose( scene.position, scene.quaternion, scene.scale );\n\n\t\t\t\t\treturn result;\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tdefault: {\n\n\t\t\t\tpromise = this.invokeOnePlugin( plugin => plugin.parseToMesh && plugin.parseToMesh( buffer, tile, extension, uri, abortSignal ) );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// wait for the tile to load\n\t\tconst result = await promise;\n\t\tif ( result === null ) {\n\n\t\t\tthrow new Error( `TilesRenderer: Content type \"${ fileType }\" not supported.` );\n\n\t\t}\n\n\t\t// get the scene data\n\t\tlet scene;\n\t\tlet metadata;\n\t\tif ( result.isObject3D ) {\n\n\t\t\tscene = result;\n\t\t\tmetadata = null;\n\n\t\t} else {\n\n\t\t\tscene = result.scene;\n\t\t\tmetadata = result;\n\n\t\t}\n\n\t\t// ensure the matrix is up to date in case the scene has a transform applied\n\t\tscene.updateMatrix();\n\t\tscene.matrix.premultiply( cachedTransform );\n\t\tscene.matrix.decompose( scene.position, scene.quaternion, scene.scale );\n\n\t\t// wait for extra processing by plugins if needed\n\t\tawait this.invokeAllPlugins( plugin => {\n\n\t\t\treturn plugin.processTileModel && plugin.processTileModel( scene, tile );\n\n\t\t} );\n\n\t\t// frustum culling\n\t\tscene.traverse( c => {\n\n\t\t\tc[ INITIAL_FRUSTUM_CULLED ] = c.frustumCulled;\n\n\t\t} );\n\t\tupdateFrustumCulled( scene, ! this.autoDisableRendererCulling );\n\n\t\t// collect all original geometries, materials, etc to be disposed of later\n\t\tconst materials = [];\n\t\tconst geometry = [];\n\t\tconst textures = [];\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.geometry ) {\n\n\t\t\t\tgeometry.push( c.geometry );\n\n\t\t\t}\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tmaterials.push( c.material );\n\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// exit early if a new request has already started\n\t\tif ( abortSignal.aborted ) {\n\n\t\t\t// dispose of any image bitmaps that have been opened.\n\t\t\t// TODO: share this code with the \"disposeTile\" code below, possibly allow for the tiles\n\t\t\t// renderer base to trigger a disposal of unneeded data\n\t\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tcached.materials = materials;\n\t\tcached.geometry = geometry;\n\t\tcached.textures = textures;\n\t\tcached.scene = scene;\n\t\tcached.metadata = metadata;\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\tsuper.disposeTile( tile );\n\n\t\t// This could get called before the tile has finished downloading\n\t\tconst cached = tile.cached;\n\t\tif ( cached.scene ) {\n\n\t\t\tconst materials = cached.materials;\n\t\t\tconst geometry = cached.geometry;\n\t\t\tconst textures = cached.textures;\n\t\t\tconst parent = cached.scene.parent;\n\n\t\t\t// dispose of any textures required by the mesh features extension\n\t\t\t// TODO: these are being discarded here to remove the image bitmaps -\n\t\t\t// can this be handled in another way? Or more generically?\n\t\t\tcached.scene.traverse( child => {\n\n\t\t\t\tif ( child.userData.meshFeatures ) {\n\n\t\t\t\t\tchild.userData.meshFeatures.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tif ( child.userData.structuralMetadata ) {\n\n\t\t\t\t\tchild.userData.structuralMetadata.dispose();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tfor ( let i = 0, l = geometry.length; i < l; i ++ ) {\n\n\t\t\t\tgeometry[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tmaterials[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tparent.remove( cached.scene );\n\n\t\t\t}\n\n\t\t\tthis.dispatchEvent( {\n\t\t\t\ttype: 'dispose-model',\n\t\t\t\tscene: cached.scene,\n\t\t\t\ttile,\n\t\t\t} );\n\n\t\t\tcached.scene = null;\n\t\t\tcached.materials = null;\n\t\t\tcached.textures = null;\n\t\t\tcached.geometry = null;\n\t\t\tcached.metadata = null;\n\n\t\t}\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst scene = tile.cached.scene;\n\t\tconst group = this.group;\n\n\t\tif ( visible ) {\n\n\t\t\tif ( scene ) {\n\n\t\t\t\tgroup.add( scene );\n\t\t\t\tscene.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( scene ) {\n\n\t\t\t\tgroup.remove( scene );\n\n\t\t\t}\n\n\t\t}\n\n\t\tsuper.setTileVisible( tile, visible );\n\n\t\tthis.dispatchEvent( {\n\t\t\ttype: 'tile-visibility-change',\n\t\t\tscene,\n\t\t\ttile,\n\t\t\tvisible,\n\t\t} );\n\n\t}\n\n\tcalculateBytesUsed( tile, scene ) {\n\n\t\tconst bytesUsed = this._bytesUsed;\n\t\tif ( ! bytesUsed.has( tile ) && scene ) {\n\n\t\t\tbytesUsed.set( tile, estimateBytesUsed( scene ) );\n\n\t\t}\n\n\t\treturn bytesUsed.get( tile ) ?? null;\n\n\t}\n\n\tcalculateTileViewError( tile, target ) {\n\n\t\tconst cached = tile.cached;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraInfo = this.cameraInfo;\n\t\tconst boundingVolume = cached.boundingVolume;\n\n\t\tlet inView = false;\n\t\tlet inViewError = - Infinity;\n\t\tlet inViewDistance = Infinity;\n\t\tlet maxError = - Infinity;\n\t\tlet minDistance = Infinity;\n\n\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t// calculate the camera error\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tlet error;\n\t\t\tlet distance;\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\tconst pixelSize = info.pixelSize;\n\t\t\t\terror = tile.geometricError / pixelSize;\n\t\t\t\tdistance = Infinity;\n\n\t\t\t} else {\n\n\t\t\t\t// avoid dividing 0 by 0 which can result in NaN. If the distance to the tile is\n\t\t\t\t// 0 then the error should be infinity.\n\t\t\t\tconst sseDenominator = info.sseDenominator;\n\t\t\t\tdistance = boundingVolume.distanceToPoint( info.position );\n\t\t\t\terror = distance === 0 ? Infinity : tile.geometricError / ( distance * sseDenominator );\n\n\t\t\t}\n\n\t\t\t// Track which camera frustums this tile is in so we can use it\n\t\t\t// to ignore the error calculations for cameras that can't see it\n\t\t\tconst frustum = cameraInfo[ i ].frustum;\n\t\t\tif ( boundingVolume.intersectsFrustum( frustum ) ) {\n\n\t\t\t\tinView = true;\n\t\t\t\tinViewError = Math.max( inViewError, error );\n\t\t\t\tinViewDistance = Math.min( inViewDistance, distance );\n\n\t\t\t}\n\n\t\t\tmaxError = Math.max( maxError, error );\n\t\t\tminDistance = Math.min( minDistance, distance );\n\n\t\t}\n\n\t\t// check the plugin visibility\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin !== this && plugin.calculateTileViewError && plugin.calculateTileViewError( tile, viewErrorTarget ) ) {\n\n\t\t\t\t// Tile shall be traversed if inView for at least one plugin.\n\t\t\t\tinView = inView && viewErrorTarget.inView;\n\t\t\t\tmaxError = Math.max( maxError, viewErrorTarget.error );\n\n\t\t\t\tif ( viewErrorTarget.inView ) {\n\n\t\t\t\t\tinViewError = Math.max( inViewError, viewErrorTarget.error );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// If the tiles are out of view then use the global distance and error calculated\n\t\tif ( inView ) {\n\n\t\t\ttarget.inView = true;\n\t\t\ttarget.error = inViewError;\n\t\t\ttarget.distanceFromCamera = inViewDistance;\n\n\t\t} else {\n\n\t\t\ttarget.inView = viewErrorTarget.inView;\n\t\t\ttarget.error = maxError;\n\t\t\ttarget.distanceFromCamera = minDistance;\n\n\t\t}\n\n\t}\n\n\t// adjust the rotation of the group such that Y is altitude, X is North, and Z is East\n\tsetLatLonToYUp( lat, lon ) {\n\n\t\tconsole.warn( 'TilesRenderer: setLatLonToYUp is deprecated. Use the ReorientationPlugin, instead.' );\n\n\t\tconst { ellipsoid, group } = this;\n\n\t\t_euler.set( Math.PI / 2, Math.PI / 2, 0 );\n\t\t_mat.makeRotationFromEuler( _euler );\n\n\t\tellipsoid.getEastNorthUpFrame( lat, lon, 0, group.matrix )\n\t\t\t.multiply( _mat )\n\t\t\t.invert()\n\t\t\t.decompose(\n\t\t\t\tgroup.position,\n\t\t\t\tgroup.quaternion,\n\t\t\t\tgroup.scale,\n\t\t\t);\n\n\t\tgroup.updateMatrixWorld( true );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.group.removeFromParent();\n\n\t}\n\n}\n"],"names":["getUrlExtension","url","endIndex","queryIndex","fragmentIndex","lastPeriodIndex","lastSlashIndex","protocolIndex","GIGABYTE_BYTES","LRUCache","cb","a","b","valA","valB","itemSet","item","bytes","bytesMap","removeCb","usedSet","itemList","callbacks","loadedSet","index","value","unloadPercent","minSize","maxSize","minBytesSize","maxBytesSize","unused","unloaded","excessNodes","excessBytes","unloadPriorityCallback","needsRerun","hasNodesToUnload","usedA","usedB","loadedA","loadedB","maxUnload","nodesToUnload","maxBytesUnload","bytesToUnload","removedNodes","removedBytes","PriorityQueue","func","priorityCallback","items","callback","data","resolve","reject","info","filter","i","maxJobs","iterated","completedCallback","result","err","viewErrorTarget","LOAD_ROOT_SIBLINGS","isDownloadFinished","LOADED","FAILED","isUsedThisFrame","tile","frameCount","areChildrenProcessed","canUnconditionallyRefine","resetFrameState","renderer","recursivelyMarkUsed","cacheOnly","markUsed","children","l","recursivelyLoadNextRenderableTiles","canTraverse","markUsedTiles","anyChildrenUsed","anyChildrenInFrustum","c","markUsedSetLeaves","allChildrenReady","childCanDisplay","isChildReady","markVisibleTiles","stats","hasContent","loadedContent","errorRequirement","meetsSSE","isAdditiveRefine","toggleTiles","isUsed","setActive","setVisible","plugin","throttle","handle","traverseSet","beforeCb","afterCb","stack","depth","parent","traverseAncestors","current","PLUGIN_REGISTERED","aPriority","bPriority","lruPriorityCallback","TilesRendererBase","tileset","isLoading","loading","total","v","UNLOADED","lruCache","downloadQueue","parseQueue","processNodeQueue","plugins","priority","insertionPoint","name","p","pending","beforecb","aftercb","ensureFullyProcessed","args","target","root","LOADING","processedUrl","error","queuedTiles","toRemove","t","scene","buffer","extension","tilesetDir","parentTile","_a","active","visible","options","immediate","child","processedTiles","json","proto","version","major","minor","basePath","res","isExternalTileset","externalTileset","uri","controller","signal","PARSING","downloadTile","content","parseTile","bytesUsed","tempMat","Matrix4","TilesGroup","Group","tilesRenderer","raycaster","intersects","force","elA","elB","isDifferent","itemA","itemB","updateParents","updateChildren","_localRay","Ray","_vec","Vector3","_hitArray","distanceSort","intersectTileScene","intersectTileSceneFirstHist","hit","isTileInitialized","raycastTraverseFirstHit","localRay","group","activeTiles","array","bestHit","bestHitDistSq","boundingVolumeDistSq","hitDistSq","raycastTraverse","boundingVolume","_worldMin","_worldMax","_norm","_ray","OBB","box","Box3","transform","Plane","source","point","ray","points","inverseTransform","min","max","x","y","z","sphere","frustum","obb","otherPlanes","otherPoints","thisPoints","thisPlanes","plane","maxDistance","j","dist","_vecX","_vecY","_vecZ","_sphereVec","_obbVec","TileBoundingVolume","sphereDistSq","obbDistSq","furthestDist","sphereDistance","obbDistance","otherSphere","otherObb","targetBox","targetMatrix","scaleX","scaleY","scaleZ","radius","Sphere","ellipsoid","west","south","east","north","minHeight","maxHeight","region","EllipsoidRegion","_mat3","Matrix3","findIntersectionPoint","plane1","plane2","plane3","A","ExtendedFrustum","Frustum","m","coordinateSystem","planes","getTextureByteLength","tex","format","type","image","width","height","TextureUtils","estimateBytesUsed","object","dedupeSet","totalBytes","_estimateBytesUsed","material","key","_mat","_euler","Euler","INITIAL_FRUSTUM_CULLED","tempVector","tempVector2","Vector2","X_AXIS","Y_AXIS","updateFrustumCulled","toInitialValue","TilesRenderer","WGS84_ELLIPSOID","LoadingManager","listener","EventDispatcher","camera","cameras","cameraMap","xOrVec","cameraVec","asset","extensions","ext","needsUpdate","cameraInfo","position","resolution","projection","w","h","found","transformArr","transformInverse","abortSignal","cached","workingPath","LoaderUtils.getWorkingPath","fetchOptions","manager","promise","cachedTransform","upRotationMatrix","fileType","LoaderUtils.readMagicBytes","loader","B3DMLoader","PNTSLoader","I3DMLoader","CMPTLoader","GLTFLoader","resourcePath","metadata","materials","geometry","textures","texture","inView","inViewError","inViewDistance","maxError","minDistance","distance","pixelSize","sseDenominator","lat","lon"],"mappings":"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"}